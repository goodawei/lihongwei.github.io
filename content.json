{"meta":{"title":"Henry","subtitle":"面朝大海，春暖花开","description":null,"author":"李宏伟","url":"http://blog.nicexiangcun.com"},"posts":[{"title":"awk","slug":"多路复用","date":"2020-03-11T13:58:51.000Z","updated":"2020-11-20T13:06:15.520Z","comments":true,"path":"2020/03/11/多路复用/","link":"","permalink":"http://blog.nicexiangcun.com/2020/03/11/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"","text":"nginx 是七成的是tcp3次握手之后的事情， 数据包： 握手的包，传输数据的包，p 标示代表客户端给服务器的数据包需要交给应用程序立即处理，立即打断缓冲区的数据立即处理，说白了，要终止当前，打断缓冲，立即执行。buffer 是不断堆积东西，到一定量就要执行。 四层网络成负责资源开辟。开辟资源后才有socket，才有文件描述符。 工具 nc（netcat） 可用模拟 服务端 和客户端。 nc -l 8081 之后等待链接 nc localhost 8081 创建客服端，连接服务端 查看nc 服务端的进程ID=2485 ps -ef | grep nc 查看nc 进程的文件描述符 cd /proc/2485/fd 可以看到任何程序都会有 0，1，2 ，同时还看到了一个socket ，0 标准输入（读） 1 标准输出（写） 2 报错。 此时还没有客户端去链接它，但是依然会有socket,只不过此时处于监听状态。现在用一个客户端去链接它，在去看描述符列表，此时就会多出一个4号。 工具 strace 可以追踪程序与系统内核的调用和信号。 mkdir -p /home/vagrant/lihongwei/strace_file 会抓取这个nc进程的所有的系统内核的调用 strace -ff -o out nc -l 8080 然后查看日志： tail -f out.2753 通过日志记录的系统函数名可以查看帮助 ，系统2类的，读文档 man 2 socket man 2 bind 程序调用 socket 执行成功会返回一个文件描述符。如上面的 socket 3, 然后就 accept 3 了。 开启追踪+开启日志监听后 启动一个客户端链接服务端。 监听到新的描述符4，同时追踪到的对系统调用的 poll(),同时阻塞到了poll。 用客户端发送字符hello给服务端，在看日志情况。 通过追踪日志可以开到，系统调用 read 从 描述符4 中读取 hello ，然后通过系统调用write 写入标准输出描述符1。 用服务端发送字符lihongwei给客户端，在看日志情况。 通过追踪日志可以开到，系统调用 read 从 标准输入描述符0 中读取 lihongwei ，然后通过系统调用write 写入描述符4（客户端）。 现在 在梳理 原始版本的 socket 过程。 先不看 poll() ,理论上只要我们得到了文件描述符，我们就可以去读它。只不过没有内容就会阻塞在那，如果描述符4一直在那阻塞，当有新的客户端完成3次握手创建了新的文件描述符5，那么5会一直在accept(). 这个过程称之为 BIO. 在后来，服务端通过多线程方式，为每个文件描述符clone 一个线程去读取，使每一个线程阻塞自己的，弊端就是客户端多了，就需要多少个客户端的线程,clone 属于系统调用，浪费资源。 在后来，非阻塞IO时期的到来（NIO），内核提供accept（），可以设置成为非阻塞了，这样主程序写一个死循环(一个线程)，read() 没有数据继续 accept(),然后创建一个队列，每次循环读取队列里的fd，看看是否是可读可写。弊端：每次都要所有的fd队列调用，如果只用第1000个fd可读可写，前面的都是浪费的，重点是还是不断的调用内核是浪费的。 man 2 select 在后来，内核 新增 select系统调用， 可以同时监听多个具柄的状态变化，应用程序调用 select 告诉内核有多少 fd.有内核完成遍历 fd，然后通知应用程序。应用程序是一个 O（1）的selct 调用，但是内核还是一个O（n）的遍历。返回可读可写的fd 给应用程序。弊端：文件描述符是有限制的 select 默认支持 1024个。 在后来，epool 的系统调用，网卡的高低压电瓶 接收数据，给内存buffer，所有设备都是谁有数据达到，就往数据总线打事件，然后触发cup中断，cpu 处理然后回掉（驱动的事情）， 利用中断产生事件原理，epool_ctl 会将链接的描述符放在内核的一个指定区域A，当有可读可写的时候，内核会通过中断机制，将可读可写的放在另一个区域B，而epool_wait 就是循环读取这个区域。 看strace 日志，有一个sendfile() 系统调用，可以查看帮助，man 2 sendfile, 实现的是一个0拷贝，是系统内核读出文件描述符，自己发送给客户端文件描述符，否则的话流程是这样的应用程序通过调用系统内核read,内核将文件内容读到内核一个缓冲区，然后应用程序在调用内核 write(), 内核在通过wirte 写给客户端文件描述符。 直接内存： 内核代码在系统启动的时候，就会被系统保护起来，称之为内核态，内核态为了防止用户态的应用程序黑客的破坏，只提供了一些可供调用的系统调用函数，而数据交互都是通过内核提供的缓冲区交互，不停的拷贝来拷贝去，效率就很低。为了提高效率，就申请了一块用户态和内核态共享的内存空间buffer，不用考呗来拷贝去。典型的一个案例是kafa,他的原理就是：客户端链接kafka 服务端broker，服务端broker，系统内核调用read，读到消息，这歩系统调用少不了，然后下一步需要写入磁盘，这一步不用在系统调用了，直接维护一个1g的共享内存，直接写内存，然后内核落入磁盘。kafaka sendfile() 和 直接内存2项技术 都用到了。 cd /usr/sbin strace -ff -o out ./nginx 看worker 进程的最终日志： 以上的一些解决方案，都是在服务端的应用程序在探索方案。 最终把 nc 换成我们日常其他的应用程序。","raw":null,"content":null,"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.nicexiangcun.com/tags/Linux/"}]},{"title":"基于docker搭建kong分布式集群","slug":"kong","date":"2020-01-07T13:52:10.000Z","updated":"2020-11-20T13:06:15.513Z","comments":true,"path":"2020/01/07/kong/","link":"","permalink":"http://blog.nicexiangcun.com/2020/01/07/kong/","excerpt":"¶创建自定义网络\ndocker network create kong-net\n¶安装kong依赖的数据库\n123456docker run -d --name kong-database \\     --network=kong-net \\     -p 5432:5432 \\     -e &quot;POSTGRES_USER=kong&quot; \\     -e &quot;POSTGRES_DB=kong&quot; \\     postgres:9.6\n12345docker run --rm \\     --network=kong-net \\     -e &quot;KONG_DATABASE=postgres&quot; \\     -e &quot;KONG_PG_HOST=kong-database&quot; \\     kong:latest kong migrations bootstrap","text":"¶创建自定义网络 docker network create kong-net ¶安装kong依赖的数据库 123456docker run -d --name kong-database \\ --network=kong-net \\ -p 5432:5432 \\ -e &quot;POSTGRES_USER=kong&quot; \\ -e &quot;POSTGRES_DB=kong&quot; \\ postgres:9.6 12345docker run --rm \\ --network=kong-net \\ -e &quot;KONG_DATABASE=postgres&quot; \\ -e &quot;KONG_PG_HOST=kong-database&quot; \\ kong:latest kong migrations bootstrap ¶安装2台kong节点 12345678910111213141516171819202122232425262728293031docker run -d --name kong-node1 \\ --network=kong-net \\ -e &quot;KONG_DATABASE=postgres&quot; \\ -e &quot;KONG_PG_HOST=kong-database&quot; \\ -e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; \\ -e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; \\ -e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; \\ -e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; \\ -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \\ -p 8000:8000 \\ -p 8443:8443 \\ -p 8001:8001 \\ -p 8444:8444 \\ kong:latestdocker run -d --name kong-node2 \\ --network=kong-net \\ -e &quot;KONG_DATABASE=postgres&quot; \\ -e &quot;KONG_PG_HOST=kong-database&quot; \\ -e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; \\ -e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; \\ -e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; \\ -e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; \\ -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \\ -p 8446:8000 \\ -p 8447:8443 \\ -p 8448:8001 \\ -p 8449:8444 \\ kong:latest ¶安装两台nginx代理 kong 默认的管理端是口8001，对外的端口是8000和8443，这里使用一台nginx代理转发到管理端口,一台转发到对外的访问端口. docker run --name nginx-node1 -p 8085:80 -d nginx docker run --name nginx-node2 -p 8086:80 -d nginx 修改nginx-node1的location 1234567891011location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Bitz_Client_IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_ignore_client_abort on; proxy_pass http://henry;&#125; henry.conf 1234567upstream henry &#123; server 10.0.208.62:8001; //admin port server 10.0.208.62:8448; //admin port #check interval=3000 rise=2 fall=5 timeout=1000 type=http; #check_http_send &quot;HEAD /op/status HTTP/1.0\\r\\n\\r\\n&quot;; #check_http_expect_alive http_2xx http_3xx;&#125; 修改nginx-node2的location 1234567891011location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Bitz_Client_IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_ignore_client_abort on; proxy_pass http://proxy_for_api;&#125; proxy_for_api.conf 1234567upstream proxy_for_api &#123; server 10.0.208.62:8000; server 10.0.208.62:8446; #check interval=3000 rise=2 fall=5 timeout=1000 type=http; #check_http_send &quot;HEAD /op/status HTTP/1.0\\r\\n\\r\\n&quot;; #check_http_expect_alive http_2xx http_3xx;&#125; ¶缓存 ¶扩展 admin api ¶查看容器状态 12345678910docker container list -adocker logs d402e041de4fdocker restart d402e041de4fdocker cp ./http_headers.lua d402e041de4f:/usr/local/openresty/lualib/resty/docker cp d402e041de4f:/usr/local/share/lua/5.1/kong/constants.lua ./","raw":null,"content":null,"categories":[{"name":"OpenResty","slug":"OpenResty","permalink":"http://blog.nicexiangcun.com/categories/OpenResty/"}],"tags":[]},{"title":"OpenResty的多级缓存库","slug":"openresty多级缓存","date":"2020-01-07T13:52:10.000Z","updated":"2020-11-20T13:06:15.514Z","comments":true,"path":"2020/01/07/openresty多级缓存/","link":"","permalink":"http://blog.nicexiangcun.com/2020/01/07/openresty%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/","excerpt":"","text":"¶lua-resty-mlcache 这个库可以作为 key/value存储来处理，但是可以缓存Lua类型和表，但是构建在lua_shared_dict，lua-resty-lrucache上 ，这种组合可以实现高性能和灵活的缓存。 功能： 使用TTL缓存和负缓存， 通过lua-resty-lock构建互斥体，以防止在缓存失败时将狗堆影响到数据库/后端， 内置worker通信，传播缓存失效，并允许worker更新他们的L1 (lua-resty-lrucache )缓存的更改(set()，delete() )， 可以创建多个独立实例来保存各种类型的数据，同时依赖同一lua_shared_dict L2缓存， 此库中内置的各种缓存级别的说明： 缓存级别层次结构为： L1 ：使用Least-Recently-Used land缓存lua-resty-lrucache ，在填充时提供最快的查找，并避免耗尽worker的Lua虚拟机内存， L2 ：所有员工共享的lua_shared_dict内存区域，只有L1未命中时才能访问此级别，并防止工作人员请求L3缓存， L3 ：自定义函数，只由单个worker运行，以避免数据库/后端(通过lua-resty-lock )上的狗堆效应，通过L3获取的值将被设置为L2缓存，供其他员工访问，","raw":null,"content":null,"categories":[{"name":"OpenResty","slug":"OpenResty","permalink":"http://blog.nicexiangcun.com/categories/OpenResty/"}],"tags":[]},{"title":"哈希表","slug":"哈希表","date":"2020-01-03T01:34:15.000Z","updated":"2020-11-20T13:06:15.520Z","comments":true,"path":"2020/01/03/哈希表/","link":"","permalink":"http://blog.nicexiangcun.com/2020/01/03/%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"\n\thashtable是由数组和列表两种数据结构组合而成的，这里面有两个重要的知识点需要掌握，一个是如何对哈希表进行动态扩容，第二个如何巧妙的设计一个散列性和性能都非常好的散列函数。\n","text":"hashtable是由数组和列表两种数据结构组合而成的，这里面有两个重要的知识点需要掌握，一个是如何对哈希表进行动态扩容，第二个如何巧妙的设计一个散列性和性能都非常好的散列函数。 ¶数组的动态扩容策略 已java的 hashmap为例，它的初始长度是16，默认阀值为0.75，当存储长度达到了长度的3/4时，就会触发扩容动作，扩容的长度为2的整数次幂，这是因为2的整数次幂的数据减1转为二进制，低位都是1，在与hashcode随机出来的数转为二进制做与运算，其结果范围一定是0-hashcode之间的范围，不会越界。 123456bucketIndex = indexFor(hash, table.length);static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; ¶散列函数 好的散列函数不但要保证计算速度快，还要保证散列性好，避免过多的碰撞，扰动函数的逻辑是将二进制数据右位移16位，正好是32bit的一半，然后自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.nicexiangcun.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"redis 主从配置","slug":"redis-replication","date":"2020-01-01T14:12:34.000Z","updated":"2020-11-20T13:06:15.517Z","comments":true,"path":"2020/01/01/redis-replication/","link":"","permalink":"http://blog.nicexiangcun.com/2020/01/01/redis-replication/","excerpt":"","text":"docker pull redis 启动master并打开redis持久化配置 docker run -p 6379:6379 -v $PWD/redis:/data -d redis redis-server --appendonly yes 查看容器信息 docker inspect d7c20d48d35c | grep IPAddress 内网IP： 172.17.0.2 启动slave1 docker run --name redis-6380 -p 6380:6379 -v $PWD/redis:/data -d redis redis-server 内网IP： 172.17.0.3 启动slave2 docker run --name redis-6381 -p 6381:6379 -v $PWD/redis:/data -d redis redis-server 内网IP： 172.17.0.4 进入2个从节点，修改配置。 docker exec -it c19b7c8c6ed1 /bin/bash 123info replication #查看角色SLAVEOF 172.17.0.2 6379 #设置master ¶配置Sentinel 分别进入3个容器配置 创建 sentinel.conf 1sentinel monitor mymaster 172.17.0.2 6379 1 每个节点启动 redis-sentinel ./sentinel.conf 首先查看哨兵监控情况,然后尝试关闭主容器,再查看剩余2个从机，这里会自动选举产生新的主机，然后，我们再次将刚才停止的主机启动起来，发现启动后其自动成为从机。","raw":null,"content":null,"categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.nicexiangcun.com/tags/redis/"}]},{"title":"OpenResty 搭建 Api Gateway","slug":"gateway","date":"2019-12-30T13:52:10.000Z","updated":"2020-11-20T13:06:15.511Z","comments":true,"path":"2019/12/30/gateway/","link":"","permalink":"http://blog.nicexiangcun.com/2019/12/30/gateway/","excerpt":"¶What\n\n\n基于Nginx和lua的高性能Web平台，内部集成了大量精良的lua库，第三方模块以及大多数依赖项，方便搭建处理高并发、扩展性极高的动态web应用、web服务，动态网关。\n\n\n扩展了Nginx的能力，将Nginx有效的变成了一个强大的web应用平台，web开发人员可以使用lua脚本调动nginx支持的各种c以及lua模块。快速构建出足以胜任c10k乃至c100k以上的单机并发连接的功性能web应用系统。\n\n\n充分利用了Nginx的非阻塞的I/O模型，不仅对HTTP请求，甚至对于远程后端诸如Mysql、PostgreSQL,Redis等都进行了一致高性能相应。\n\n\n¶使用场景\n\n网关&amp;web防火墙：如数据前置校验，缓存前置，数据过滤，API请求聚合，ABtest,降级，监控等，可以进行 IP/URL/UserAgent/Referer 黑名单，限流等。\n\n站内应用案例：\n","text":"¶What 基于Nginx和lua的高性能Web平台，内部集成了大量精良的lua库，第三方模块以及大多数依赖项，方便搭建处理高并发、扩展性极高的动态web应用、web服务，动态网关。 扩展了Nginx的能力，将Nginx有效的变成了一个强大的web应用平台，web开发人员可以使用lua脚本调动nginx支持的各种c以及lua模块。快速构建出足以胜任c10k乃至c100k以上的单机并发连接的功性能web应用系统。 充分利用了Nginx的非阻塞的I/O模型，不仅对HTTP请求，甚至对于远程后端诸如Mysql、PostgreSQL,Redis等都进行了一致高性能相应。 ¶使用场景 网关&amp;web防火墙：如数据前置校验，缓存前置，数据过滤，API请求聚合，ABtest,降级，监控等，可以进行 IP/URL/UserAgent/Referer 黑名单，限流等。 站内应用案例： 图中golang注册中心服务负责将后台提交的规则信息以插件化的形式进行打包处理后提交至gateway管理中心，gateway加载插件处理流量。 web应用：会进行一些业务逻辑处理，一般流程 mysql/redis/http获取数据返回前端，如京东商品详情页。 利用OpenResty对于后端的远程存储可以进行高性能相应，可以代替类似于php-fpm对后端远程存储访问瓶颈的限制，转为由OpenResty请求，获取结果后通知给应用后端服务。 12docker pull redis:latestdocker run -p 6379:6379 --name redis -v $PWD/redis.conf:/root/redis/redis.conf -v $PWD/data:/root/redis/data -d redis redis-server 123456789101112131415161718 location /lua &#123; content_by_lua_block &#123; local redis = require &quot;resty.redis&quot; local red = redis:new() red:set_timeout(1000) local ok, err = red:connect(&quot;127.0.0.1&quot;, 6379) if not ok then ngx.say(&quot;failed to connect: &quot;, err) return end ok, err = red:set(&quot;color&quot;, &quot;red&quot;) if not ok then ngx.say(&quot;failed to set dog: &quot;, err) return end ngx.say(red:get(&quot;color&quot;)) &#125;&#125; 缓存：可以对相应内容进行缓存，减少后端请求，以及规则下发。 OpenResty 提供了lru和shared纯内存缓存服务。 12345678910111213141516lua_shared_dict books 1m;location /book &#123; content_by_lua_block &#123; local cache = ngx.shared.books local len, err = cache:lpush(&quot;foo&quot;, &quot;bar&quot;) if len then ngx.say(&quot;push success&quot;) else ngx.say(&quot;push err: &quot;, err) end cache:set(&quot;lua&quot;, &quot;lua&quot;) ngx.print(cache:get(&quot;lua&quot;)) cache:set(&quot;kind&quot;, require(&quot;cjson&quot;).encode(&#123;php=7&#125;)) ngx.print(require(&quot;cjson&quot;).decode(cache:get(&quot;kind&quot;)).php) &#125;&#125; 12345678910location /lru &#123; content_by_lua_block &#123; local lrucache = require &quot;resty.lrucache&quot; local cache, err = lrucache.new(200) cache:set(&quot;dog&quot;, 32, 0.03) ngx.sleep(0.02) local data, stale_data = cache:get(&quot;dog&quot;) ngx.print(stale_data) &#125;&#125; 123OpenResty -s quit -p `pwd`/ -c conf/nginx.confOpenResty -p `pwd`/ -c conf/nginx.conf","raw":null,"content":null,"categories":[{"name":"OpenResty","slug":"OpenResty","permalink":"http://blog.nicexiangcun.com/categories/OpenResty/"}],"tags":[]},{"title":"数组和链表","slug":"数组和链表","date":"2019-12-26T01:34:15.000Z","updated":"2020-11-20T13:06:15.521Z","comments":true,"path":"2019/12/26/数组和链表/","link":"","permalink":"http://blog.nicexiangcun.com/2019/12/26/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/","excerpt":"数组的特点是在内存中地址是连续的，所以在随机访问一个数组中的地址的时间复杂度是O(1),寻址公式大概是：\n123456789\tint a[3] = &#123;1,2,3&#125;;a[i]_address = begin_address + i * data_type_sizeint a[3][2] = &#123;&#123;1,2&#125;,&#123;6,7&#125;,&#123;3,5&#125;&#125;;address = begin_address + ( i * n + j) * data_type_size\n数组由于对内存的要求比较苛刻，带来的一个问题就是低效的“插入”和“删除”，在做数据的插入和删除的时候要频繁的进行数据的迁移。对于数组的动态扩容策略的实现可以参考redis的字符串底层实现原理或者java中的arrayList&lt;&gt;.","text":"数组的特点是在内存中地址是连续的，所以在随机访问一个数组中的地址的时间复杂度是O(1),寻址公式大概是： 123456789 int a[3] = &#123;1,2,3&#125;;a[i]_address = begin_address + i * data_type_sizeint a[3][2] = &#123;&#123;1,2&#125;,&#123;6,7&#125;,&#123;3,5&#125;&#125;;address = begin_address + ( i * n + j) * data_type_size 数组由于对内存的要求比较苛刻，带来的一个问题就是低效的“插入”和“删除”，在做数据的插入和删除的时候要频繁的进行数据的迁移。对于数组的动态扩容策略的实现可以参考redis的字符串底层实现原理或者java中的arrayList&lt;&gt;. 使用场景注意： 操作的数据不宜过大。 链表的分类： 单链表： 后继指针指next向下一个节点的heac（节点包含头部，数据data和指针next） 双向链表： 后继指针next指向下一个节点的prev (节点包括前驱指针prev,数据data,后继指针next) 循环链表： 尾结点指针指向头节点 链表就是用指针将节点连接起来，它对内存的要求没有数组那么苛刻，所以链表在“插入”和“删除”的动作上的时间复杂度是O(1),但是由于链表内存不是连续的，所以不能随机访问某个元素，在查找的时候时间复杂度是O(n)。 单链表的使用经典案例如：LRU缓存淘汰策略 双向链表：java中的LinkedHashMap实现，双向链表比单链表会占用更多的内存，但是在查找元素的速度上会比单链表性能更高，因为双向链表的每个节点上既有前驱指针，又有后继指针，当我们知道具体某一个node的时候那么它的前驱和后继指针我们就知道了，所以它在查找过程中可以判断是忘前走还是往后走，体现了用空间换时间的设计思想。 链表的另一种使用场景经常会配合散列表使用，配合hashtable使用的目的主要是为了解决链表在查询过程中时间复杂度O(N)的问题。做法是将单链表或者双链表中的节点通过hash函数散列到数组的槽(桶)上，用一个新的指针通过拉链的方式将冲突的节点连接上。这样在查找某一个node的时候，时间复杂度是接近O(1)的。","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.nicexiangcun.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"linux中内存字节对齐","slug":"内存字节对齐","date":"2019-12-25T13:34:15.000Z","updated":"2020-11-20T13:06:15.520Z","comments":true,"path":"2019/12/25/内存字节对齐/","link":"","permalink":"http://blog.nicexiangcun.com/2019/12/25/%E5%86%85%E5%AD%98%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/","excerpt":"🍒 linux下默认字节对齐是以int类型变量所占字节数对齐，也就是说会申请被4整除的内存地址写入int类型，所以这就是我们每次看int类型的地址不会看到有奇数的。\n¶什么叫对齐\n计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。\n¶为什么要进行对齐\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据（linux中：在内存中是低位在先，高位在后）。显然在读取效率上下降很多。\n例1程序分配的内存地址如下图：","text":"🍒 linux下默认字节对齐是以int类型变量所占字节数对齐，也就是说会申请被4整除的内存地址写入int类型，所以这就是我们每次看int类型的地址不会看到有奇数的。 ¶什么叫对齐 计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。 ¶为什么要进行对齐 各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据（linux中：在内存中是低位在先，高位在后）。显然在读取效率上下降很多。 例1程序分配的内存地址如下图： 12345678910#include&lt;stdio.h&gt; int main()&#123; double a = 9.99; char b = &#x27;1&#x27;; int c = 1; printf(&quot;%p,sizeof(a):%lu\\n&quot;,&amp;a,sizeof(a)); printf(&quot;%p,sizeof(b):%lu\\n&quot;,&amp;b,sizeof(b)); printf(&quot;%p,sizeof(c):%lu\\n&quot;,&amp;c,sizeof(c)); &#125; 例2程序分配的内存地址如下图： 1234567891011#include&lt;stdio.h&gt;int main()&#123; char a = &#x27;1&#x27;; double b = 9.99; char c = &#x27;1&#x27;; int d = 1; printf(&quot;%p,sizeof(a):%lu\\n&quot;,&amp;a,sizeof(a)); printf(&quot;%p,sizeof(b):%lu\\n&quot;,&amp;b,sizeof(b)); printf(&quot;%p,sizeof(c):%lu\\n&quot;,&amp;c,sizeof(c)); printf(&quot;%p,sizeof(d):%lu\\n&quot;,&amp;d,sizeof(d));&#125;","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"http://blog.nicexiangcun.com/categories/linux/"}],"tags":[]},{"title":"代码整洁之道之技巧总结","slug":"code-summarize","date":"2019-11-30T14:48:12.000Z","updated":"2020-11-20T13:06:15.511Z","comments":true,"path":"2019/11/30/code-summarize/","link":"","permalink":"http://blog.nicexiangcun.com/2019/11/30/code-summarize/","excerpt":"\n优雅的代码应该是什么样的\n\n能够满足当前的需求（功能，稳定性，负载能力等）。\n对未来的需求，能够快速的扩展，修改。\n出现问题能够快速的定位问题方便修改问题。\n尽量避免重复，最大程度复用。\n\n针对这些问题，整理出一些自己对于设计模式的理解，其实设计模式就是别人走过的路，踩过的坑，总结出来的优秀经验。总结的代码整洁之道就是如何复用这些经验。\n下面是代码整洁之道第一篇：技巧总结 🙏","text":"优雅的代码应该是什么样的 能够满足当前的需求（功能，稳定性，负载能力等）。 对未来的需求，能够快速的扩展，修改。 出现问题能够快速的定位问题方便修改问题。 尽量避免重复，最大程度复用。 针对这些问题，整理出一些自己对于设计模式的理解，其实设计模式就是别人走过的路，踩过的坑，总结出来的优秀经验。总结的代码整洁之道就是如何复用这些经验。 下面是代码整洁之道第一篇：技巧总结 🙏 1.命名非常重要，就为了可读性更好。 2.适当的使用注释，开发新功能，修改别人的bug,关键业务逻辑，要合理的使用注释 3.变量需要初始化 4.1==$a 和常量比较常量在前,防御编程，避免误写出$a=1 5.防御式编程和契约编程 默认不信任任何外部调用和方法，默认双方遵守契约，任意一方撕毁契约则抛出异常，建议在UI及应用层倾向于防御式编程保证友好及体验，在逻辑层倾向于契约式编程尽早暴露隐患 6.可控的环境参数 🐛 代码不受环境的影响，各种魔术常亮，声明字符集，定义包含的绝对路径，错误级别7，自己开发的测试，准生产，生产环境切好等 🕷️ 7.PHP结束标记 纯php语句不要结束标记 8.if的使用技巧之“给定初始值” 9.if的使用技巧之“用&quot;&amp;&amp;&quot; 替换 if” 1234567if($rand&gt;3)&#123; $long=5;&#125;$rand&gt;3 &amp;&amp; $long=5; 10.if的使用技巧之“用三元运算符替换if” 11.if的使用技巧之“去掉多此一举的if” 123456789if(1==$a)&#123; return true;&#125;else&#123; return false;&#125;return (1==$a); 12.表驱动法 map 在php中数组使用的是hashtable，时间复杂度是O(1),运行速度远远高于以上两种，另外书写起来也更简便的多。如果传入的参数是开始未定义的也不会运行查找浪费大量的系统资源。 13.使用更精悍短小的代码 函数的最佳最大长度是150行代码，这样的代码比较便于维护，也方便修改，对于某些过于集中的算法函数，可能长度会大于这个长度。不过尽量还是不要超过，短小的才是美好的，短小的便于理解也便于修改，而功能相对单一的代码也就意味着可以复用它的地方会更多，有更好的复用性，另外当程序出问题的时候，测试起来也会相对简单好定位，便于维护修改。 14.避免使用幻数 ,幻数，简单来说既是我们所说的硬编码. 15.中间结果赋值给变量 当一个表达式中嵌套层数过多，逻辑过于复杂的时候，将其拆分成一块块的，将其每一块的结果赋值给中间变量，这样可以降低程序的阅读难度和提高可维护性。 16.复杂的逻辑表达式做成布尔函数 当某一个判断比较复杂的时候，可以考虑将其做成一个布尔函数，不要怕这个函数里面的代码少，很多时候这样写可以使你的逻辑更容易维护，另外碰到相同逻辑判定的地点还可以直接复用，不需要一处修改处处修改。 17.永远不要复制粘贴雷同的代码 大段相同的代码实现类似的但是略有不同的程序功能的时候，我们很容易就回进行复制完后修改，其实这种做法会有很大的问题. 18.备份源代码文件","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代码整洁之道之对象间的发布订阅","slug":"code-summarize-three","date":"2019-11-30T14:19:37.000Z","updated":"2020-11-20T13:06:15.510Z","comments":true,"path":"2019/11/30/code-summarize-three/","link":"","permalink":"http://blog.nicexiangcun.com/2019/11/30/code-summarize-three/","excerpt":"实现laravel中 Observer模式三种方式：\n\n框架本地的Events事件机制\nPHP定义了两个接口：SplObserver和SplSubject\n自定义Observer 和 Subject\n\n不管采用哪种方式其目的是：对象更改其状态时，将通知附加的“观察者”。它用于缩短耦合对象的数量，并使用松耦合。\n举个缓存依赖例子：🐶","text":"实现laravel中 Observer模式三种方式： 框架本地的Events事件机制 PHP定义了两个接口：SplObserver和SplSubject 自定义Observer 和 Subject 不管采用哪种方式其目的是：对象更改其状态时，将通知附加的“观察者”。它用于缩短耦合对象的数量，并使用松耦合。 举个缓存依赖例子：🐶 12345678910111213//如果数据源发生变化根据cacheType清空不同数据缓存class CacheRepository implements Cache &#123; protected $catenation; public function __construct($db) &#123; $this-&gt;catenation = $db; &#125; public function cacheClear($cacheType) &#123; // &#125;&#125; 123456789101112131415161718//mem 观察员class MemcacheObserver implements \\SplObserver&#123; public function update(Cache $cache) &#123; $cache-&gt;clean(&#x27;mem&#x27;); &#125; /** * @return List[] */ public function getArticles(): array &#123; return $this-&gt;getArticles; &#125;&#125; 12345678910//mon 观察员class MongodbObserver implements \\SplObserver&#123; public function update(Cache $cache) &#123; $cache-&gt;clean(&#x27;mon&#x27;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233//缓存对象class CacheSubject implements \\SplSubject&#123; /** * @var \\SplObjectStorage */ private $observers; public function __construct() &#123; $this-&gt;observers = new \\SplObjectStorage(); &#125; public function attach(\\SplObserver $observer) &#123; $this-&gt;observers-&gt;attach($observer); &#125; public function detach(\\SplObserver $observer) &#123; $this-&gt;observers-&gt;detach($observer); &#125; public function notify(Cache $cache) &#123; /** @var \\SplObserver $observer */ foreach ($this-&gt;observers as $observer) &#123; $observer-&gt;update($cache); &#125; &#125;&#125; 12345678910111213141516171819202122232425//更新数据源class ArticleController &#123; private $memcache; private $mongodb; private $cacheSub; public function __construct(CacheSubject $cacheSub ) &#123; $this-&gt;cacheSub = $cacheSub; &#125; public function postUpdate($id) &#123; //添加订阅对象，此处是主动添加观察者，理想状态应该是观察者主动来订阅，做成事件配置，notify去读取配置 $this-&gt;cacheSub-&gt;attach(MemcacheObserver $this-&gt;memcache); $this-&gt;cacheSub-&gt;attach(MongodbObserver $this-&gt;mongodb); //更新数据源 self::update([&#x27;id&#x27;=&gt;$id]); //通知订阅者 $this-&gt;cacheSub-&gt;notify(Cache $cache); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"How do you understand yield in php","slug":"yield","date":"2019-11-30T13:43:35.000Z","updated":"2020-11-20T13:06:15.520Z","comments":true,"path":"2019/11/30/yield/","link":"","permalink":"http://blog.nicexiangcun.com/2019/11/30/yield/","excerpt":"yield 迭代器 协程  💤\n我们知道cpu是按照时间片段执行的程序的，php中当线程遇到yield的时候，可以让出cpu去执行另外一段程序，是表示协程最初始的一种形态。真正意义上的协程要复杂的多，比如通常会在影响性能的网络io环节实现协程处理，是应用程序在处理网络io的时候让出cpu去处理其他事情。\n¶从系统内存等资源开销角度考虑其使用场景\n大文件读取，一次性取出大的数据集 🌱\nyield 的优势在于每次迭代只是到当前的yield就返回了，下次迭代在从它记录的位置在往下执行。不会消耗过多的系统资源。因为协程是程序之间上下文的切换，要比线程之间切换带来系统开销小。","text":"yield 迭代器 协程 💤 我们知道cpu是按照时间片段执行的程序的，php中当线程遇到yield的时候，可以让出cpu去执行另外一段程序，是表示协程最初始的一种形态。真正意义上的协程要复杂的多，比如通常会在影响性能的网络io环节实现协程处理，是应用程序在处理网络io的时候让出cpu去处理其他事情。 ¶从系统内存等资源开销角度考虑其使用场景 大文件读取，一次性取出大的数据集 🌱 yield 的优势在于每次迭代只是到当前的yield就返回了，下次迭代在从它记录的位置在往下执行。不会消耗过多的系统资源。因为协程是程序之间上下文的切换，要比线程之间切换带来系统开销小。 1234567891011121314151617public function nowExcute(Request $request)&#123; foreach($this-&gt;fib() as $mobile)&#123; echo $mobile.PHP_EOL ; &#125;&#125;public function fib()&#123; $handle = fopen(&#x27;http://uc.dev/Jbh-JKFKLSJFKL4394.txt&#x27;, &quot;r&quot;); while (!feof ($handle)) &#123; $buffer = fgets($handle); yield trim($buffer); &#125; fclose ($handle);&#125; ¶从算法设计角度考虑其使用场景 斐波那契数列的实现 ☄️ 123456789101112131415 foreach($this-&gt;fib(10) as $n)&#123; echo $n.PHP_EOL;&#125;public function fib($num)&#123; $n = 0 ; $a = 0 ; $b=1; while($n &lt; $num)&#123; yield $b ; $t = $a ; $a = $b; $b = $b+$t; $n++; &#125;&#125; 123456def fin(num): n,a,b = 0,0,1 while n&lt;num: yield b a,b = b,a+b ¶从程序功能设计角度考虑的使用场景 管道模式的实现 1234567(begin) ----------------&gt; function() -----------------&gt; (end) ^ ^ ^ ^ ^ ^ | | | | | | | | +------- M1() ------+ | | | +----------- ... ----------+ | +--------------- Mn() --------------+ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function middleware($handlers,$arguments = [])&#123; //函数栈 $stack = []; $result = null; foreach ($handlers as $handler) &#123; // 每次循环之前重置，只能保存最后一个处理程序的返回值 $result = null; $generator = call_user_func_array($handler, $arguments); if ($generator instanceof \\Generator) &#123; //将协程函数入栈,为重入做准备 $stack[] = $generator; //获取协程返回参数,到第一个yield地方返回，yield以下的程序在栈里取出在执行 $yieldValue = $generator-&gt;current(); //检查是否重入函数栈 if ($yieldValue === false) &#123; break; &#125; &#125; elseif ($generator !== null) &#123; //不属于迭代器的function,获取function的返回值 $result = $generator; &#125; &#125; $return = ($result !== null); //将协程函数出栈 while ($generator = array_pop($stack)) &#123; if ($return) &#123; $generator-&gt;send($result); &#125; else &#123; $generator-&gt;next(); &#125; &#125; &#125; $logMiddleware = function()&#123; echo &quot;日志中间件：进参记录日志 \\n&quot;; yield; echo &quot;日志中间件：出参记录日志 \\n&quot;; &#125;; $validatorMiddleware = function ()&#123; echo &quot;验证器中间件：前置验证器中间件 \\n&quot;; $returnParms = yield; print_r($returnParms).&quot;\\n&quot;; echo &quot;验证器中间件：后置验证器中间件 \\n&quot;; &#125;; $handle = function ()&#123; return [&#x27;your English name&#x27;=&gt;&#x27;Henry&#x27;]; &#125;; middleware([$logMiddleware,$validatorMiddleware,$handle]); 输出如下： 1234567日志中间件：进参记录日志验证器中间件：前置验证器中间件array(&#x27;your English name&#x27;=&gt;&#x27;Henry&#x27;)验证器中间件：后置验证器中间件日志中间件：出参记录日志","raw":null,"content":null,"categories":[],"tags":[{"name":"协程","slug":"协程","permalink":"http://blog.nicexiangcun.com/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"代码整洁之道之优化嵌套代码","slug":"code-summarize-two","date":"2019-11-30T12:44:30.000Z","updated":"2020-11-20T13:06:15.511Z","comments":true,"path":"2019/11/30/code-summarize-two/","link":"","permalink":"http://blog.nicexiangcun.com/2019/11/30/code-summarize-two/","excerpt":"☘️ if else 和 switch case 优化方案\n1 如果嵌套逻辑是 返回值或者输出等简单的一句话代码，则使用表驱动方案。\n2 如果是逻辑处理或者函数调用，则采用策略和多态模式。\n举个例子：\n123456789101112$type = $data[&#x27;type&#x27;]; //1-绑卡 2-充值switch ($type) &#123;    case 1:        $res = (new AccountPermission())-&gt;bindCard($account);        break;    case 2:        $res = (new AccountPermission())-&gt;recharge($account);        break;&#125;","text":"☘️ if else 和 switch case 优化方案 1 如果嵌套逻辑是 返回值或者输出等简单的一句话代码，则使用表驱动方案。 2 如果是逻辑处理或者函数调用，则采用策略和多态模式。 举个例子： 123456789101112$type = $data[&#x27;type&#x27;]; //1-绑卡 2-充值switch ($type) &#123; case 1: $res = (new AccountPermission())-&gt;bindCard($account); break; case 2: $res = (new AccountPermission())-&gt;recharge($account); break;&#125; 以上这个例子逻辑大概就是根据客户端传递的type去调用不同的验证方法，这样写违背了设计原则之中的针对扩展开放，修改关闭原则，如果有新增type类型那么必须要修改此文件和AccountPermission文件，另外函数的封装要尽可能的短小精悍，代码逻辑直截了当并尽可能的减少依赖关系，这样才能体现出只做好一件事情。那么针对这些问题，以上的代码优化思路是这样的： 1 定义抽象类或者接口 AbstractPermission 1234abstract class AbstractPermission&#123; abstract public function validator(...$data);&#125; 2 创建不同的验证实体去实现或者继承AbstractPermission 1234567//BindCard的验证实体class BindCardPermission extends AbstractPermission&#123; public function validator(...$parms)&#123; //todo &#125;&#125; 1234567//Recharge的验证实体class RechargePermission extends AbstractPermission&#123; public function validator(...$parms)&#123; //todo &#125;&#125; 3 创建工厂将创建实体的过程封装起来，在业务层通过策略来动态获取实例对象 1234567891011//当然此处的工厂实例最好也要去继承或者实现一个抽象工厂class FactoryPermission&#123; const PERMISSION = &#x27;Permission&#x27;; public static function permission($permission,$parms)&#123; $class = $permission. constant(__CLASS__ . &quot;::PERMISSION&quot;); $permissionObj = &quot;App\\\\&#123;$class&#125;&quot;; return call_user_func_array( [new $permissionObj(),&#x27;validator&#x27;], [$parms]); &#125;&#125; 4 如何使用，这里就要去设计一套策略了，可以结合创建工厂的步骤设计具体的策略 1234// type 传递 BindCard Recharge ....$type = $data[&#x27;type&#x27;];$parms = $data[&#x27;parms&#x27;];$res = FactoryPermission::permission($type,$parms) 总结：将职责单一，减少依赖，针对扩展开放修改关闭，这样以后有新增type只需要扩展新增的permission实体，而不需要修改任何其他文件。","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"awk","slug":"awk","date":"2019-11-29T13:58:51.000Z","updated":"2020-11-20T13:06:15.510Z","comments":true,"path":"2019/11/29/awk/","link":"","permalink":"http://blog.nicexiangcun.com/2019/11/29/awk/","excerpt":"Reference：https://www.gnu.org/software/gawk/manual/gawk.html#Running-gawk\n1234567891011Amelia       555-5553     amelia.zodiacusque@gmail.com    FAnthony      555-3412     anthony.asserturo@hotmail.com   ABecky        555-7685     becky.algebrarum@gmail.com      ABill         555-1675     bill.drowning@hotmail.com       ABroderick    555-0542     broderick.aliquotiens@yahoo.com RCamilla      555-2912     camilla.infusarum@skynet.be     RFabius       555-1234     fabius.undevicesimus@ucb.edu    FJulie        555-6699     julie.perscrutabor@skeeve.com   FMartin       555-6480     martin.codicibus@hotmail.com    ASamuel       555-3430     samuel.lanceolis@shu.edu        AJean-Paul    555-2127     jeanpaul.campanorum@nyu.edu     R\n¶按 $0 查找匹配元素\n12345awk &#x27;/li/ &#123;print $0&#125;&#x27; 2017.log &lt;=&gt;grep li 2017.log//不同的是 ‘/’ is called a regular expression,","text":"Reference：https://www.gnu.org/software/gawk/manual/gawk.html#Running-gawk 1234567891011Amelia 555-5553 amelia.zodiacusque@gmail.com FAnthony 555-3412 anthony.asserturo@hotmail.com ABecky 555-7685 becky.algebrarum@gmail.com ABill 555-1675 bill.drowning@hotmail.com ABroderick 555-0542 broderick.aliquotiens@yahoo.com RCamilla 555-2912 camilla.infusarum@skynet.be RFabius 555-1234 fabius.undevicesimus@ucb.edu FJulie 555-6699 julie.perscrutabor@skeeve.com FMartin 555-6480 martin.codicibus@hotmail.com ASamuel 555-3430 samuel.lanceolis@shu.edu AJean-Paul 555-2127 jeanpaul.campanorum@nyu.edu R ¶按 $0 查找匹配元素 12345awk &#x27;/li/ &#123;print $0&#125;&#x27; 2017.log &lt;=&gt;grep li 2017.log//不同的是 ‘/’ is called a regular expression, ¶切割 slice uuidd:x:107:111::/run/uuidd:/bin/false 如果每行串都有某个特殊字符可以按照特殊字符切割字符串。 12345awk -F &#x27;:&#x27; &#x27; /redis/ &#123; print $1 &#125;&#x27; /etc/passwdawk -F &#x27;:&#x27; &#x27;/redis/ &#123; print $1 &#125;&#x27; /etc/passwd | wc -lawk -F &#x27;:&#x27; &#x27; &#123; print $1 &#125;&#x27; /etc/passwd | sort ¶COUNT THIS FILE 统计文件有多少列 awk 'END &#123; print NF &#125;' 2017.log 统计文件有多少行 awk 'END &#123; print NR &#125;' 2017.log","raw":null,"content":null,"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.nicexiangcun.com/tags/Linux/"}]},{"title":"Best practice for feature switch of devops","slug":"devops-featur-switch","date":"2019-11-28T13:55:47.000Z","updated":"2020-11-20T13:06:15.511Z","comments":true,"path":"2019/11/28/devops-featur-switch/","link":"","permalink":"http://blog.nicexiangcun.com/2019/11/28/devops-featur-switch/","excerpt":"¶为什么要使用特性开关?\n\n上线周期短，屏蔽在单一上线周期内已开发但未完成的特性（例如每周两次上线，但“产品列表”功能需要三周才能开发完成）\n对比在不同 UI 下的用户行为和转化率（A/B Testing）\n部署与发布分离，持续频繁部署，业务随时可发布\n部署：代码部署到生产环境\n发布：特性上线，交付给最终用户使用,部署与发布分离，开发团队频繁持续进行部署，而业务人员（需求方）决定特性何时发布。\n\n","text":"¶为什么要使用特性开关? 上线周期短，屏蔽在单一上线周期内已开发但未完成的特性（例如每周两次上线，但“产品列表”功能需要三周才能开发完成） 对比在不同 UI 下的用户行为和转化率（A/B Testing） 部署与发布分离，持续频繁部署，业务随时可发布 部署：代码部署到生产环境 发布：特性上线，交付给最终用户使用,部署与发布分离，开发团队频繁持续进行部署，而业务人员（需求方）决定特性何时发布。 ¶为什么不继续使用旧做法（挑代码）？ 旧做法：每次发布前，从代码仓库中，由开发组长从最近的若干提交中，手工挑选出需要上线的若干个提交，测试人员进行测试并发布。 这种做法： 生产环境和开发主干代码不一致，违背了单一主干代码的策略，造成代码库版本碎片化 与持续集成理念背道而驰（不能早期集成、早期测试、提供快速反馈） ¶为什么不用 Git Branch？ Long-lived feature branch是一个常见的持续交付反模式。这是因为：如果项目拥有多个长期彼此独立演进的分支，往往需要等到最后发布时才合并代码，这与持续集成的最佳实践背道而驰。 可参见 ThoughtWorks技术雷达相关介绍：https://www.thoughtworks.com/radar/techniques/long-lived-branches-with-gitflow ¶特性开关是解决问题的最后手段 为了隐藏未完成的特性进入生产环境，我们应遵循以下步骤： 首先考虑将大的业务特性分解，分批次小步引入新的特性。这样做的好处是减少上线风险，并收集用户对于新特性的真实使用反馈，便于持续改进该特性。 其次，可以考虑新特性UI的入口地址与已有UI分离，给新特性赋予一个全新的URL，但不暴露该地址给真实用户，即可隐藏未完成的特性。最后才考虑特性开关，作为解决问题的最后手段。 ¶使用特性开关的注意事项 使用特性开关包裹某一特性时，要特别注意不要遗漏某些特性代码在开关范围之外。 使用了特性开关后，测试人员的测试策略 - 通常说来只需测试下列两种情况： 启用所有下一次上线发布时需要的功能的情况 启用所有功能的情况 由特性开关控制的功能正式上线并稳定后，务必要去掉特性开关代码，包括配置文件中特性开关变量以及所有使用特性开关的代码。 特性开关数量不能太多，一旦超过限定数量，务必清理已有特性开关","raw":null,"content":null,"categories":[{"name":"devops","slug":"devops","permalink":"http://blog.nicexiangcun.com/categories/devops/"}],"tags":[{"name":"devops","slug":"devops","permalink":"http://blog.nicexiangcun.com/tags/devops/"}]},{"title":"好心修改别人的代码却带来新的bug","slug":"bug-with-auther","date":"2019-02-24T13:50:13.000Z","updated":"2020-11-20T13:06:15.510Z","comments":true,"path":"2019/02/24/bug-with-auther/","link":"","permalink":"http://blog.nicexiangcun.com/2019/02/24/bug-with-auther/","excerpt":"","text":"有时候非常严重的问题，就是你常常忽略的小不点。 开发过程中，有时候会遇到要修改别人的代码，那么怎么确保不会带出新的问题出来呢🙏我们的鹏飞老大给出了几条建议💯。 UnitTest，仔细想了想，单元测试真的是太有必要了。 代码走查，优秀的技术团队通常都会有，走查和分享的环节。 开发纪律上以下上原话 代码块注释：标明作者、时间、描述 原则上不允许擅自修改他人代码：如需修改需通知作者配合修改，如无法通知作者则必须慎重修改且须有测试保障 防御式编程与契约式编程：默认不信任任何外部调用和方法，默认双方遵守契约，任意一方撕毁契约则抛出异常，建议在UI及应用层倾向于防御式编程保证友好及体验，在逻辑层倾向于契约式编程尽早暴露隐患","raw":null,"content":null,"categories":[{"name":"bug","slug":"bug","permalink":"http://blog.nicexiangcun.com/categories/bug/"}],"tags":[{"name":"bug","slug":"bug","permalink":"http://blog.nicexiangcun.com/tags/bug/"}]},{"title":"Never forget why you started, and your mission can be accomplished.","slug":"today-idea-20171021","date":"2017-10-21T11:17:12.000Z","updated":"2020-11-20T13:06:15.518Z","comments":true,"path":"2017/10/21/today-idea-20171021/","link":"","permalink":"http://blog.nicexiangcun.com/2017/10/21/today-idea-20171021/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[]},{"title":"About swoole questions","slug":"swoole","date":"2017-09-21T15:01:21.000Z","updated":"2020-11-20T13:06:15.518Z","comments":true,"path":"2017/09/21/swoole/","link":"","permalink":"http://blog.nicexiangcun.com/2017/09/21/swoole/","excerpt":"","text":"12345678/*** fpm only can use Synchronous client*/public function fpm()&#123; $parms = &#x27;parms&#x27;; $this-&gt;tcpClient($parms);// throw a error Swoole\\Client is must cli&#125; 1234567891011121314151617181920212223242526272829303132public function serv() &#123; /** * Swoole has three mode pattern maybe refence: https://wiki.swoole.com/wiki/page/353.html * have a question at here but i don&#x27;t know , if not use SWOOLE_BASE there is a error about epoll */ $serv = new \\Swoole\\Http\\Server(&quot;0,0,0,0&quot;, 9508,SWOOLE_BASE, SWOOLE_SOCK_TCP); $serv-&gt;on(&#x27;Request&#x27;, function($request, $response) &#123; $arrParms = [ &#x27;channel&#x27;=&gt; isset($request-&gt;get[&#x27;channel&#x27;]) ? $request-&gt;get[&#x27;channel&#x27;] : &#x27;&#x27;, &#x27;uid&#x27; =&gt; isset($request-&gt;get[&#x27;uid&#x27;]) ? $request-&gt;get[&#x27;uid&#x27;] : &#x27;&#x27;, ]; $class = &#x27;BindCard&#x27;. constant(__CLASS__ . &quot;::PERM&quot;); $obj = &quot;App\\\\Http\\\\Controllers\\\\&#123;$class&#125;&quot;; call_user_func_array(array(new $obj(),&#x27;bandCard&#x27;), [$arrParms]); $response-&gt;cookie(&quot;User&quot;, &quot;Swoole&quot;); $response-&gt;cookie(&quot;english_name&quot;, &quot;Henry&quot;); $response-&gt;cookie(&quot;channel&quot;, $arrParms[&#x27;channel&#x27;]); $response-&gt;header(&quot;X-Server&quot;, &quot;Swoole&quot;); $json = json_encode([ &#x27;uid&#x27;=&gt;$arrParms[&#x27;uid&#x27;], &#x27;chanle&#x27;=&gt;$arrParms[&#x27;channel&#x27;], ]); $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole!&lt;/h1&gt;&quot;.$json); &#125;); $serv-&gt;start(); &#125; 123456789101112131415161718192021222324252627282930313233class BindCardRepository&#123; public function bandCard($parms) &#123; $parms +=[ &#x27;data&#x27;=&gt;&#x27;&#x27; ]; $this-&gt;tcpClient($parms); &#125; public function tcpClient($parms) &#123; $client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC); //设置事件回调函数 $client-&gt;on(&quot;connect&quot;, function($cli) use ($parms)&#123; //log $cli-&gt;send(serialize($parms)); &#125;); $client-&gt;on(&quot;receive&quot;, function($cli, $data)&#123; // when reveived data do somethings print_r(unserialize($data)); &#125;); $client-&gt;on(&quot;error&quot;, function($cli)&#123; echo &quot;Connect failed\\n&quot;; &#125;); $client-&gt;on(&quot;close&quot;, function($cli)&#123; echo &quot;Connection close\\n&quot;; &#125;); //发起网络连接 $client-&gt;connect(&#x27;192.168.10.10&#x27;, 9503, 0.5); &#125;&#125; 12345678910111213141516171819202122public function tcpServer() &#123; $serv = new \\Swoole\\Server(&quot;192.168.10.10&quot;, 9503,SWOOLE_BASE, SWOOLE_SOCK_TCP); $serv-&gt;set(array( &#x27;daemonize&#x27; =&gt; false, &#x27;reactor_num&#x27; =&gt; 2, &#x27;worker_num&#x27; =&gt; 4 )); $serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd)&#123; echo &quot;This Tcp Server is Connected.\\n&quot;; &#125;); $serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $from_id, $data) &#123; // do log and do somethings. $hanleData = unserialize($data); $serv-&gt;send($fd, $data); $serv-&gt;close($fd); &#125;); $serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Tcp Client: Close.\\n&quot;; &#125;); $serv-&gt;start(); &#125;","raw":null,"content":null,"categories":[],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://blog.nicexiangcun.com/tags/swoole/"}]},{"title":"Here are some thing about redis","slug":"build-redis","date":"2017-09-21T14:50:41.000Z","updated":"2020-11-20T13:06:15.510Z","comments":true,"path":"2017/09/21/build-redis/","link":"","permalink":"http://blog.nicexiangcun.com/2017/09/21/build-redis/","excerpt":"","text":"123456789101112# check redis statusps -aux | grep redis# list statusredis 950 0.1 0.3 40436 8124 ? Ssl 02:11 0:24 /usr/bin/redis-server 127.0.0.1:6379vagrant 4688 0.0 0.0 14520 1092 pts/0 S+ 06:13 0:00 grep--color=auto redis# into serverredis-cli -h 127.0.0.1 -p 6379# show all keykeys *# check key&#x27;s typetype your key 12345678910111213141516171819use App\\Http\\Controllers\\Controller;use App\\Jobs\\ThisIsTestJob;use Illuminate\\Foundation\\Bus\\DispatchesJobs;class ThisIsTestBuHenryController extends Controller&#123; use DispatchesJobs; public function fire() &#123; // reference http://www.cnblogs.com/z1298703836/p/5346728.html // If use delay i don&#x27;t know is there any problem in redis it is zset // php artisan queue:work redis : yourself can run this command // php artisan queue:work redis --queue=emails : yourself can run this command that only specify queue name $this-&gt;dispatch((new ThisIsTestJob())-&gt;onQueue((&#x27;register&#x27;))); //$this-&gt;dispatch((new ThisIsTestJob())-&gt;delay(60)-&gt;onQueue((&#x27;emails&#x27;))); //$this-&gt;dispatch((new ThisIsTestJob())); dd(&#x27;hello world&#x27;); &#125;&#125; ¶Supervisor 12345678910111213141516171819202122[program:artisan]command = /usr/bin/php /home/vagrant/Code/jbh-oauth/artisan queue:work --sleep=3 --tries=3 --queue=register --daemondirectory = /home/vagrant/Code/jbh-oauthautostart = trueautorestart = truestdout_logfile = /home/logs/supervisor/supervisor_queue.logstdout_logfile_maxbytes = 10MBstderr_logfile = /home/logs/supervisor/supervisor_queue.logstderr_logfile_maxbytes = 10MB# check sudo supervisorctl reloadsudo supervisorctl restart artisansudo supervisorctl stop artisansudo supervisorctl start artisansudo supervisorctl status all","raw":null,"content":null,"categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.nicexiangcun.com/tags/redis/"}]},{"title":"positive energy","slug":"powerful","date":"2017-08-22T14:26:14.000Z","updated":"2020-11-20T13:06:15.516Z","comments":true,"path":"2017/08/22/powerful/","link":"","permalink":"http://blog.nicexiangcun.com/2017/08/22/powerful/","excerpt":"","text":"Your opponents are reading. Your dushman are burnishing knief. Your bestie are Reducing weight. Next door Lao Wang is exercising waist. we must keep learning ,if not we will be overtaken by rivals.","raw":null,"content":null,"categories":[],"tags":[{"name":"powerful","slug":"powerful","permalink":"http://blog.nicexiangcun.com/tags/powerful/"}]},{"title":"About Python bit operation","slug":"python-位运算","date":"2017-07-26T15:17:38.000Z","updated":"2020-11-20T13:06:15.517Z","comments":true,"path":"2017/07/26/python-位运算/","link":"","permalink":"http://blog.nicexiangcun.com/2017/07/26/python-%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;Python bit operation,when use bit operation case&quot;&quot;&quot;RECHARGE = 2&gt;&gt;1WITHRAW = 2&lt;&lt;0INVENT = 2&lt;&lt;1BANDCARD = 2&lt;&lt;2&quot;&quot;&quot;If somebody will going to check recharge and bandcard,like this.&quot;&quot;&quot;this_user = RECHARGE | BANDCARD &quot;&quot;&quot;How can check user like this.&quot;&quot;&quot;if this_user &amp; RECHARGE: print(&#x27;recharge is ok&#x27;)if this_user &amp; WITHRAW: print(&#x27;withraw is ok&#x27;)if this_user &amp; BANDCARD: print(&#x27;bandcard is ok&#x27;)if this_user &amp; INVENT: print(&#x27;invent is ok&#x27;)","raw":null,"content":null,"categories":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/tags/python/"}]},{"title":"About Python Decorator","slug":"python-装饰器","date":"2017-07-26T15:07:28.000Z","updated":"2020-11-20T13:06:15.517Z","comments":true,"path":"2017/07/26/python-装饰器/","link":"","permalink":"http://blog.nicexiangcun.com/2017/07/26/python-%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"Decorator 一个函数原有功能不变的情况下，增强这个函数的功能，这个就是装饰器。\ncase: when you difined a function , then you want to add some functions in it,but you don’t want modify this function.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;This is a test decorator,it useful is going to print messages or bring function at a function&#x27;s front and end.&quot;&quot;&quot;def at_front_end_print(fun):    def byfun(*arg,**keyarg):        print(&#x27;At %s function\\&#x27;s front print:&#x27; %(fun.__name__))        fun(*arg,**keyarg)        print(&#x27;At %s function\\&#x27;s end print:&#x27; %(fun.__name__))    return byfun&quot;&quot;&quot;This is a test function,it test decorator at_front_end_print&quot;&quot;&quot;@at_front_end_printdef get_user_info(uid):    print(&#x27;This user id is %d :&#x27; %uid )&quot;&quot;&quot;This is a test function,it test decorator at_front_end_print&quot;&quot;&quot;@at_front_end_printdef check_user_bank_card(user , type=1):    print(&#x27;Do check %s user\\&#x27;s status, for %d&#x27; %(user,type))get_user_info(100)check_user_bank_card(101,8)&quot;&quot;&quot;This follow Decorator may pass args for example: decorator&#x27;s function do sign , like this it need three floors deep.&quot;&quot;&quot;def base_sign(sign_key):    def decorator(fun):        def byfun(*arg , **keyargs):            print(&#x27;This sector handle sign for %s :&#x27; % fun.__name__,&#x27;it\\&#x27;s sign key is %s&#x27; %sign_key)            fun(*arg , **keyargs)        return byfun    return decorator&quot;&quot;&quot;This is a open user api&quot;&quot;&quot;@base_sign(sign_key=&#x27;abc&#x27;)def open_user(uid):    print(&#x27;This sector is handle user open %d:&#x27; %uid)&quot;&quot;&quot;This is a bank user api&quot;&quot;&quot;@base_sign(&#x27;def&#x27;)def bank_user(uid):    print(&#x27;This sector is handle user bank %d:&#x27; %uid)open_user(200)bank_user(201)","text":"Decorator 一个函数原有功能不变的情况下，增强这个函数的功能，这个就是装饰器。 case: when you difined a function , then you want to add some functions in it,but you don’t want modify this function. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;This is a test decorator,it useful is going to print messages or bring function at a function&#x27;s front and end.&quot;&quot;&quot;def at_front_end_print(fun): def byfun(*arg,**keyarg): print(&#x27;At %s function\\&#x27;s front print:&#x27; %(fun.__name__)) fun(*arg,**keyarg) print(&#x27;At %s function\\&#x27;s end print:&#x27; %(fun.__name__)) return byfun&quot;&quot;&quot;This is a test function,it test decorator at_front_end_print&quot;&quot;&quot;@at_front_end_printdef get_user_info(uid): print(&#x27;This user id is %d :&#x27; %uid )&quot;&quot;&quot;This is a test function,it test decorator at_front_end_print&quot;&quot;&quot;@at_front_end_printdef check_user_bank_card(user , type=1): print(&#x27;Do check %s user\\&#x27;s status, for %d&#x27; %(user,type))get_user_info(100)check_user_bank_card(101,8)&quot;&quot;&quot;This follow Decorator may pass args for example: decorator&#x27;s function do sign , like this it need three floors deep.&quot;&quot;&quot;def base_sign(sign_key): def decorator(fun): def byfun(*arg , **keyargs): print(&#x27;This sector handle sign for %s :&#x27; % fun.__name__,&#x27;it\\&#x27;s sign key is %s&#x27; %sign_key) fun(*arg , **keyargs) return byfun return decorator&quot;&quot;&quot;This is a open user api&quot;&quot;&quot;@base_sign(sign_key=&#x27;abc&#x27;)def open_user(uid): print(&#x27;This sector is handle user open %d:&#x27; %uid)&quot;&quot;&quot;This is a bank user api&quot;&quot;&quot;@base_sign(&#x27;def&#x27;)def bank_user(uid): print(&#x27;This sector is handle user bank %d:&#x27; %uid)open_user(200)bank_user(201) 装饰器作用: 简化代码，避免function重复代码 打印日志：@log , 带参数@log(‘DEBUG’) @log(‘INFO’) 检测性能：@performance 数据库事务：@transaction Url路由：@post(‘/register’)","raw":null,"content":null,"categories":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/tags/python/"}]},{"title":"Python 高阶函数","slug":"python-高阶函数","date":"2017-07-24T14:04:09.000Z","updated":"2020-11-20T13:06:15.517Z","comments":true,"path":"2017/07/24/python-高阶函数/","link":"","permalink":"http://blog.nicexiangcun.com/2017/07/24/python-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"¶reference:  http://book.pythontips.com/en/latest/\nLet’s going to understand Python’s map , reduce , filter.","text":"¶reference: http://book.pythontips.com/en/latest/ Let’s going to understand Python’s map , reduce , filter. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python3# -*- coding: utf-8 -*-from functools import reduce# use input,like Php readline extinput = input(&quot;please input:&quot;)print(list(map(int , input.split(&#x27;,&#x27;))))str = &#x27;dd,wer, &#x27;print(str.lstrip(&#x27;d&#x27;))# use MapfruitList = [&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;]# this map returns is an iterable object. so i don&#x27;t understand how can i retrieve or take out i want elementsiterter = map(lambda item: item+&quot;s&quot; , fruitList)for value in iterter: print(value)# list is may any data type even object or function for example# if you invest 10000 yuan and you need to know each manth&#x27;s replay plan,then i hope define 12 manth handle to give map listsdef getJan(money): return &#x27;this is Jan\\&#x27;s repaly plan&#x27;def getFeb(money): return &#x27;this is Feb\\&#x27;s replay plan&#x27;def getMar(money): return &#x27;this is Mar\\&#x27;s replay plan&#x27;money = 10000rep = map(lambda getRepaly : getRepaly(money) , [getJan,getFeb,getMar])for value in rep: print(value)#filter : as the name suggests , it return a list elements for which a function returns true.prepareFilter = [&#x27;php&#x27;,&#x27;java&#x27;,&#x27;python&#x27;];for value in filter(lambda language: language != &#x27;php&#x27; , prepareFilter): print(value)# reduce It applies a rolling computation to sequential pairs of values in a list.# Notice : If you want to use reduce need to from functools import reducepoints = [1,2,3,4,5];print(reduce(lambda x ,y: x+y ,points))","raw":null,"content":null,"categories":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/tags/python/"}]},{"title":"Python AES and PHP AES","slug":"python-aes","date":"2017-07-24T13:53:25.000Z","updated":"2020-11-20T13:06:15.516Z","comments":true,"path":"2017/07/24/python-aes/","link":"","permalink":"http://blog.nicexiangcun.com/2017/07/24/python-aes/","excerpt":"When i try use Python’s package of json.dumps,I find the result is difference PHP, There is a question about Python’s json.dumps. It can behand : add a place.(它会在 ‘:’ 后放置一个空格，而像PHP这样的语言是没有这样的hash.这样导致两种语言的AES结果不一致).","text":"When i try use Python’s package of json.dumps,I find the result is difference PHP, There is a question about Python’s json.dumps. It can behand : add a place.(它会在 ‘:’ 后放置一个空格，而像PHP这样的语言是没有这样的hash.这样导致两种语言的AES结果不一致). 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env python3# -*- coding: utf-8 -*-from Crypto.Cipher import AESimport jsonimport base64import hashlibkey= &#x27;LJl:*DOOUV8(&#123;t11&#x27;;iv = &#x27;OK~aAEHi&#123;yxfXDf4&#x27;;#这里密钥key 长度必须为16（AES-128）,#24（AES-192）,或者32 （AES-256）Bytes 长度#目前AES-128 足够目前使用BS = 16#pad = lambda s: s + (BS - len(s) % BS) * &#x27;\\0&#x27;pad = lambda s: s + (BS - len(s) % BS) * chr(0)Aesdata = &#123;&#x27;uid&#x27;:&#x27;361503611&#x27;&#125;#text = json.dumps(Aesdata, sort_keys=True, indent=4, separators=(&#x27;,&#x27;, &#x27;:&#x27;))text = json.dumps(Aesdata,separators=(&#x27;,&#x27;, &#x27;:&#x27;))cryptor = AES.new(key,AES.MODE_CBC,iv)# do AESciphertext = cryptor.encrypt(pad(text))#因为AES加密时候得到的字符串不一定是ascii字符集的，输出到终端或者保存时候可能存在问题#所以这里统一把加密后的字符串转化为 base64 或者 16进制字符串rew = base64.b64encode(ciphertext)# md5md = hashlib.md5()sign = &#x27;H*a1CsCDFIJIL*Ib&#x27;+rew.decode()+&#x27;bim09e0d656374f46228c5205fe66f06ba7&#x27;md.update(sign.encode(&#x27;UTF-8&#x27;))print(md.hexdigest()) 我大PHP very easier 12345678910static function encrypt($data,$key,$iv)&#123; $cipher = MCRYPT_RIJNDAEL_128; $mode = MCRYPT_MODE_CBC; $data=json_encode($data); $encrypt_data = mcrypt_encrypt($cipher, $key, $data, $mode, $iv); $data= base64_encode($encrypt_data); return $data;&#125;","raw":null,"content":null,"categories":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/tags/python/"}]},{"title":"java－基础整数运算","slug":"java-整数运算","date":"2017-07-23T15:11:03.000Z","updated":"2020-11-20T13:06:15.512Z","comments":true,"path":"2017/07/23/java-整数运算/","link":"","permalink":"http://blog.nicexiangcun.com/2017/07/23/java-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/","excerpt":"¶整数运算\n整数除法仍然是整数，%可以取余。\n自增和自减运算：++和--，注意是先引用在自增，还是先自增在引用的差别。\n简写的+=和-=\n计算结果溢出不报错，但结果是错误的。 在计算过程中我们没有必要为了减少内存，采用byte,short等短类型进行计算。\n¶移位运算\n左移：&lt;&lt;\n右移：&gt;&gt;\n无条件右移：&gt;&gt;&gt;\nbyte 和 short 会先转换为int在移位\n注意移位如果超出了范围则直接被丢弃。For explame 5120 &gt;&gt; 11位\n\nint 类型如上图在内存中占32位存储空间其中最高位是符号位。在右移过程中可以用&gt;&gt;&gt;强制右移，将直接移动最高位的二进制数。\n","text":"¶整数运算 整数除法仍然是整数，%可以取余。 自增和自减运算：++和--，注意是先引用在自增，还是先自增在引用的差别。 简写的+=和-= 计算结果溢出不报错，但结果是错误的。 在计算过程中我们没有必要为了减少内存，采用byte,short等短类型进行计算。 ¶移位运算 左移：&lt;&lt; 右移：&gt;&gt; 无条件右移：&gt;&gt;&gt; byte 和 short 会先转换为int在移位 注意移位如果超出了范围则直接被丢弃。For explame 5120 &gt;&gt; 11位 int 类型如上图在内存中占32位存储空间其中最高位是符号位。在右移过程中可以用&gt;&gt;&gt;强制右移，将直接移动最高位的二进制数。 ¶位运算 位运算过程中会先按位对齐，然后一次按位进行与运算或者或运算For example: ¶异或运算 ¶运算过程中类型的自动提升 Notice: 不能将较大的类型参与进入一个较小类型的运算当中。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://blog.nicexiangcun.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.nicexiangcun.com/tags/Java/"}]},{"title":"代码整洁之用责任链条重构你的if else","slug":"责任链","date":"2017-05-30T12:31:42.000Z","updated":"2020-11-20T13:06:15.522Z","comments":true,"path":"2017/05/30/责任链/","link":"","permalink":"http://blog.nicexiangcun.com/2017/05/30/%E8%B4%A3%E4%BB%BB%E9%93%BE/","excerpt":"\n职责链模式是使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n构造责任链条chain的两种方式：\n1 通过函数方法属性构造 eg :\n12345678910111213abstract class  RepaymentCalculateAbstract&#123;    protected $next ;    public function setNextCalculate(RepaymentCalculateAbstract $nextCalculate)    &#123;        $this-&gt;next = $nextCalculate;    &#125;       abstract public function calculate($parms) ;    &#125;","text":"职责链模式是使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 构造责任链条chain的两种方式： 1 通过函数方法属性构造 eg : 12345678910111213abstract class RepaymentCalculateAbstract&#123; protected $next ; public function setNextCalculate(RepaymentCalculateAbstract $nextCalculate) &#123; $this-&gt;next = $nextCalculate; &#125; abstract public function calculate($parms) ; &#125; 1234567891011class JanuaryRepayment extends RepaymentCalculateAbstract&#123; public function calculate($parms) &#123; //pass echo &#x27;Jan-&#x27;.$parms ; $this-&gt;next-&gt;calculate($parms); &#125;&#125; 12345678910class FebruaryRepayment extends RepaymentCalculateAbstract&#123; public function calculate($parms) &#123; //pass $parms = 100 + $parms ; echo &#x27;Feb&#x27;.$parms ; $this-&gt;next-&gt;calculate($parms); &#125;&#125; 12345678910class MarchRepayment extends RepaymentCalculateAbstract&#123; public function calculate($parms) &#123; //pass $parms = 100 + $parms; echo &#x27;Mar&#x27;.$parms ; //$this-&gt;next-&gt;calculate($parms); &#125;&#125; 123456789class AppRepaymentCalculate extends RestAbstractController&#123; public function calculate(Request $request , FebruaryRepayment $Feb , JanuaryRepayment $Jan ,MarchRepayment $Mar) &#123; $Jan-&gt;setNextCalculate($Feb) ; $Feb-&gt;setNextCalculate($Mar); $Jan-&gt;calculate(&#x27;100&#x27;) ; &#125;&#125; 2 构造注入链条，通过在父类做切面代理调用子类的 processing ： eg 12345678910111213141516171819202122232425262728293031abstract class Handler&#123; /** * @var Handler|null */ private $successor = null; public function __construct(Handler $handler = null) &#123; $this-&gt;successor = $handler; &#125; /** * This approach by using a template method pattern ensures you that * each subclass will not forget to call the successor * * @param RequestInterface $request * * @return string|null */ final public function handle(RequestInterface $request) &#123; $processed = $this-&gt;processing($request); if ($processed === null) &#123; // the request has not been processed by this handler =&gt; see the next if ($this-&gt;successor !== null) &#123; $processed = $this-&gt;successor-&gt;handle($request); &#125; &#125; return $processed; &#125; abstract protected function processing(RequestInterface $request); 12345678910111213141516171819202122232425262728293031323334class HttpInMemoryCacheHandler extends Handler&#123; /** * @var array */ private $data; /** * @param array $data * @param Handler|null $successor */ public function __construct(array $data, Handler $successor = null) &#123; parent::__construct($successor); $this-&gt;data = $data; &#125; /** * @param RequestInterface $request * * @return string|null */ protected function processing(RequestInterface $request) &#123; $key = sprintf( &#x27;%s?%s&#x27;, $request-&gt;getUri()-&gt;getPath(), $request-&gt;getUri()-&gt;getQuery() ); if ($request-&gt;getMethod() == &#x27;GET&#x27; &amp;&amp; isset($this-&gt;data[$key])) &#123; return $this-&gt;data[$key]; &#125; return null; &#125;&#125; 12345678910111213class SlowDatabaseHandler extends Handler&#123; /** * @param RequestInterface $request * * @return string|null */ protected function processing(RequestInterface $request) &#123; // this is a mockup, in production code you would ask a slow (compared to in-memory) DB for the results return &#x27;Hello World!&#x27;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637class ChainTest extends TestCase&#123; /** * @var Handler */ private $chain; protected function setUp() &#123; $this-&gt;chain = new HttpInMemoryCacheHandler( [&#x27;/foo/bar?index=1&#x27; =&gt; &#x27;Hello In Memory!&#x27;], new SlowDatabaseHandler() ); &#125; public function testCanRequestKeyInFastStorage() &#123; $uri = $this-&gt;createMock(&#x27;Psr\\Http\\Message\\UriInterface&#x27;); $uri-&gt;method(&#x27;getPath&#x27;)-&gt;willReturn(&#x27;/foo/bar&#x27;); $uri-&gt;method(&#x27;getQuery&#x27;)-&gt;willReturn(&#x27;index=1&#x27;); $request = $this-&gt;createMock(&#x27;Psr\\Http\\Message\\RequestInterface&#x27;); $request-&gt;method(&#x27;getMethod&#x27;) -&gt;willReturn(&#x27;GET&#x27;); $request-&gt;method(&#x27;getUri&#x27;)-&gt;willReturn($uri); $this-&gt;assertEquals(&#x27;Hello In Memory!&#x27;, $this-&gt;chain-&gt;handle($request)); &#125; public function testCanRequestKeyInSlowStorage() &#123; $uri = $this-&gt;createMock(&#x27;Psr\\Http\\Message\\UriInterface&#x27;); $uri-&gt;method(&#x27;getPath&#x27;)-&gt;willReturn(&#x27;/foo/baz&#x27;); $uri-&gt;method(&#x27;getQuery&#x27;)-&gt;willReturn(&#x27;&#x27;); $request = $this-&gt;createMock(&#x27;Psr\\Http\\Message\\RequestInterface&#x27;); $request-&gt;method(&#x27;getMethod&#x27;) -&gt;willReturn(&#x27;GET&#x27;); $request-&gt;method(&#x27;getUri&#x27;)-&gt;willReturn($uri); $this-&gt;assertEquals(&#x27;Hello World!&#x27;, $this-&gt;chain-&gt;handle($request)); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Practice of devops thinking","slug":"devops-thinking","date":"2017-05-14T13:47:58.000Z","updated":"2020-11-20T13:06:15.511Z","comments":true,"path":"2017/05/14/devops-thinking/","link":"","permalink":"http://blog.nicexiangcun.com/2017/05/14/devops-thinking/","excerpt":"¶精益思想：消除浪费\n\n以越来越少的投入——较少的人力、较少的设备、较短的时间和较小的场地创造出尽可能多的价值；\n越来越接近用户，提供他们确实要的东西，精确地定义价值\n确定每个产品的全部价值流；\n使保留下来的、创造价值的各个步骤流动起来，缩短周期\n及时跟上不断变化着的顾客需求\n精益思想包括精益生产、精益管理、精益设计和精益供应等一系列思想，其核心是通过及时适量、零库存、传票卡等现场管理手段实现订货生产，从而确保产品质量并降低成本。“精”体现在质量上，追求尽善尽美、精益求精；“益”体现在成本上，只有成本低于行业平均成本的企业才能获得收益。因而，精益思想不单纯追求成本最低、企业眼中的质量最优，而是追求用户和企业都满意的质量、追求成本与质量的最佳配置、追求产品性能价格的最优比。\n\n¶敏捷选型：SCRUM\n","text":"¶精益思想：消除浪费 以越来越少的投入——较少的人力、较少的设备、较短的时间和较小的场地创造出尽可能多的价值； 越来越接近用户，提供他们确实要的东西，精确地定义价值 确定每个产品的全部价值流； 使保留下来的、创造价值的各个步骤流动起来，缩短周期 及时跟上不断变化着的顾客需求 精益思想包括精益生产、精益管理、精益设计和精益供应等一系列思想，其核心是通过及时适量、零库存、传票卡等现场管理手段实现订货生产，从而确保产品质量并降低成本。“精”体现在质量上，追求尽善尽美、精益求精；“益”体现在成本上，只有成本低于行业平均成本的企业才能获得收益。因而，精益思想不单纯追求成本最低、企业眼中的质量最优，而是追求用户和企业都满意的质量、追求成本与质量的最佳配置、追求产品性能价格的最优比。 ¶敏捷选型：SCRUM 角色：产品负责人（PO）—— 敏捷教练（SM）—— 自组织开发团队（DT） Scrum过程框架的基石： 透明性：看板管理（Product Backlog、SPRINT BACKLOG、BURN-DOWN CHART） 为了增强面对面沟通，前三个月建议使用白板进行，之后可以使用 JIRA 等看板系统 检验和适应：产品待办事项列表梳理、Sprint计划会议、每日站会、Sprint评审、Sprint回顾会议 每日站会： 15分钟以内完成，每个人回答三个问题 我昨天完成了什么任务？ 我今天打算做什么任务？ 我遇到了哪些障碍或困难？ ¶持续交付模型：敏捷开发 + 版本管理 +单元测试 + 代码审查 + 集成构建 + 自动化测试 持续交付工具链： intelliJ -&gt; gitlab -&gt; sonar -&gt; jenkins -&gt; SIT 统一的代码管理：gitlab 分支策略： dev（SIT） release（UAT） master（PRO）注意事项：每个人每天都要向代码库主干提交代码 严格的代码审查机制：sonar 规则：New bugs &lt;= 0 , New Vulnerabilities &lt;= 0 ,注意事项：只有通过代码审查的代码才能进行构建 集成构建：jenkins , 流程模板：代码更新,单元测试,代码检查,部署测试环境,接口测试 部署策略： dev分支-&gt; SIT环境,release分支 -&gt; UAT环境 -&gt; PRO环境,PRO环境 -&gt; master分支 注意事项： 每日至少构建一次,过程不不能存在人工干预,修复失败的构建是优先级最高的事情 summarize ： DevOps = 精益思想 + 敏捷开发 + 持续交付","raw":null,"content":null,"categories":[{"name":"devops","slug":"devops","permalink":"http://blog.nicexiangcun.com/categories/devops/"}],"tags":[{"name":"devops","slug":"devops","permalink":"http://blog.nicexiangcun.com/tags/devops/"}]},{"title":"Best Practice Of Jenkins","slug":"jenkins","date":"2017-05-11T14:57:34.000Z","updated":"2020-11-20T13:06:15.512Z","comments":true,"path":"2017/05/11/jenkins/","link":"","permalink":"http://blog.nicexiangcun.com/2017/05/11/jenkins/","excerpt":"¶Jenkins交付流水\nDevOps和产品团队需要熟悉的Jenkins技能\n\n持续集成\n\n\n持续集成概念简介\n项目交付流水线：持续集成的表现形式\nWeb和Mobile项目的典型交付流水线\n\n\nJenkins持续集成系统\n\n\nJenkins的特点\n理解流水线即代码（Pipeline as Code）\n\n\nJenkins的使用\n\n\n流水线的目录层级规划\n在Jenkins中创建流水线\n\n\n配置定时检查代码更新\n配置带输入参数的流水线\n添加流水线内容\n\n\nJenkinsfile的使用\n\n\nJenkinsfile的管理：项目中的pipeline目录\n标准流水线的常见步骤\n常用的Jenkinsfile语法\nJenkins中的Pipeline Syntax工具\n\n","text":"¶Jenkins交付流水 DevOps和产品团队需要熟悉的Jenkins技能 持续集成 持续集成概念简介 项目交付流水线：持续集成的表现形式 Web和Mobile项目的典型交付流水线 Jenkins持续集成系统 Jenkins的特点 理解流水线即代码（Pipeline as Code） Jenkins的使用 流水线的目录层级规划 在Jenkins中创建流水线 配置定时检查代码更新 配置带输入参数的流水线 添加流水线内容 Jenkinsfile的使用 Jenkinsfile的管理：项目中的pipeline目录 标准流水线的常见步骤 常用的Jenkinsfile语法 Jenkins中的Pipeline Syntax工具 ¶建议阅读材料 Jenkins Pipeline官方教程： https://github.com/jenkinsci/pipeline-plugin/blob/master/TUTORIAL.md Jenkins Pipeline的10个最佳实践： http://www.cnblogs.com/itech/p/5678643.html Jenkinsfile官方示例： https://github.com/jenkinsci/pipeline-examples ¶持续集成基础概念 持续集成，Continuous integration ，简称CI。 随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。 持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。 以一个比较典型的大型IT项目为例。 首先，解释下集成。我们所有项目的代码都是托管在Git服务器上。每个项目都要有若干个单元测试，只有在本地电脑上通过了单元测试的代码才能上传到Git服务器上，保证上传的代码没有问题。代码进入流水线以后会经历一系列的预定过程，比如确认单元测试通过，代码静态检查和测试环境的部署等，然后会进入集成测试阶段。集成测试是指将多个软件组件连接后，通过自动化的手段检查组件直接的通信是否被破坏，因此这里的“集成”指就是指的集成测试。 再说持续。不言而喻，就是指长期的对项目代码进行集成测试。既然是长期，那肯定是自动执行的，否则，人工执行则没有保证，而且耗人力。对此，我们有一台服务器，它会检查Git仓库的代码变更，当代码仓库内容发生变化以后，它需要更新本地代码，重新编译，然后跑集成测试。每次集成测试结果都会记录在案。完成这方面工作的就是Jenkins软件，当然，它的功能远不止这些。 持续集成的特点： 它是一个自动化的周期性的集成测试过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，无需人工干预； 需要有专门的集成服务器来执行集成构建； 需要有代码托管工具支持； 持续集成的作用： 保证团队开发人员提交代码的质量，减轻了软件发布时的压力 持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、费用和工作量； ¶Jenkins安装与配置 Jenkins是一个开源的实现持续集成的软件工具。它能实时监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 官方网站：http://jenkins.io Jenkins的特点： 易安装：仅仅一个 java -jar jenkins.war，从官网下载该文件后，直接运行，无需额外的安装，更无需安装数据库； 易配置：提供友好的GUI配置界面； 变更支持：Jenkins能从代码仓库（Svn/Git）中获取并产生代码更新列表并显示到流水线信息中； 支持永久链接：用户是通过web来访问Jenkins的，而这些web页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接； 集成E-Mail/RSS/IM：当完成一次集成完成时，可通过这些工具实时告诉你集成结果（集成测试通常需要花费一定时间，有了这个功能，就可以在等待结果过程中，干别的事情）； JUnit/TestNG测试报告：也就是用以图表等形式提供详细的测试报表功能； 支持分布式构建：Jenkins可以把集成构建等工作分发到多台计算机中完成； 文件指纹信息：Jenkins会保存哪次集成构建产生了哪些产物文件，哪一次集成测试的环境是哪个版本部署的等记录 支持第三方插件：使得Jenkins 变得越来越强大； ¶部署Jenkins服务 安装环境介绍 系统：CentOS6.5_x64 Jenkins：2.19.3，路径为 /opt/soft/jenkins JDK：jdk1.8.0_51，路径为 /opt/jdk1.8.0_51 机器 IP：10.70.71.235 安装 Jenkins 新建 /opt/soft/jenkins 目录 jenkins 官网下载 war 包 将 jenkins.war 拷贝到此目录下 初始化运行，执行以下命令，默认以管理员身份启动运行 123456cd /opt/soft/jenkins;export JAVA_HOME=/opt/jdk1.8.0_51;export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH;export JENKINS_HOME=/opt/soft/jenkins/workdir/;java -jar /opt/soft/jenkins/jenkins.war --httpPort=80//在浏览器里输入 10.70.71.235，可以进入 Jenkins 配置 Jenkins 从左侧面板的“系统管理”按钮进入配置管理页面 首先点击“管理插件”页面，在“高级”Tab页上传必要的插件，包括Git、Gitlab Auth、Role-Based Authorization等 然后进入“Configure Global Security”页面，勾选“启用安全”，安全域里选择Gitlab登录，并添加相关信息 在“Configure Global Security”页面的安全域“权限”中选择“Role-Based Strategy”，然后到“Manage and Assign Roles”页面配置项目角色和权限 域名映射 启动时，设置 --httpPort=80，再由网管指定域名 http://jenkins.haihangyun.com 映射即可 集成Gitlab登录后，用户登录时会跳转到Gitlab页面，此时可用海航域账号登录，完成后会跳转回到Jenkins首页。 ¶Jenkins发布流水线 部署流水线： Jenkins提供很好的持续集成/交付的支持。 通常流水线的设计是从Gitlab获取代码更新开始的，对于单开发分支+单发布分支的项目，应该对应有两条甚至多条流水线。 一个比较完整的部署流程如下图： 创建流水线: 进入jenkins界面后，点击左上角新建按钮，出现如下界面 依据需要创建子目录或流水线 如果需要创建的是子目录，在界面中填写目录名称，并且选择下方的Folder选项 为同一项目搭建的流水线应该放置于同一目录下。 点击保存后，在界面会出现新建的目录 点击目录名称进入目录内，在左侧的按钮可以继续创建子目录和流水线。 如果创建的是流水线，填写流水线名称，并选择Pipeline选项,流水线的创建完成 ¶Jenkins配置流水线内容 打开新建流水线，点击左侧configure按钮。进入配置界面。具体有两种方式： 直接填写在界面中,选择Pipeline script，如下图所示： 使用SCM,在Defintion部分选择 Pipeline script from SCM。在SCM类型中选择Git，填写Pipeline script所在代码仓库和分支以及脚本文件路径。 至此一条流水线搭建完成。 ¶典型的流水线模板 对于不同类型的应用，所需的流水线会有差异。例如Web应用通常需要设计自动化部署的流程，而Mobile的应用则通常只能到达打包的步骤。 以聚宝滙产品为例。一个比较规范的Web项目流水线如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354withEnv([&#x27;PATH=/usr/local/bin:$PATH&#x27;]) &#123; node &#123; stage(&#x27;代码更新&#x27;) &#123; checkout scm: [$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;*/dev&#x27;]], userRemoteConfigs: [[url: &#x27;git@gitbj.haihangyun.com:JBH/web.git&#x27;]]] &#125; stage(&#x27;单元测试&#x27;) &#123; sh &quot;phpunit&quot; &#125; stage(&#x27;代码检查&#x27;) &#123; sh &quot;sonar-scanner -Dsonar.login=&#x27;jenkins&#x27; -Dsonar.password=&#x27;jenkins&#x27; -Dsonar.host.url=http://sonar.haihangyun.com&quot; sh &quot;bash ./pipeline/checkSonarStatus.sh&quot; &#125; &#125; stage(&#x27;部署确认&#x27;) &#123; timeout(time:1, unit:&#x27;HOURS&#x27;) &#123; milestone() input &quot;现在执行部署？&quot; &#125; &#125; node &#123; lock(resource: &#x27;WEB_PAAS&#x27;, inversePrecedence: true) &#123; stage(&#x27;部署PaaS云主站服务&#x27;) &#123; sh &#x27;bash ./pipeline/buildImage.sh dev&#x27; sh &#x27;bash ./pipeline/makesureImageReady.sh dev&#x27; sh &quot;bash ./pipeline/deployImage.sh dev&quot; sh &quot;bash ./pipeline/waitDeployment.sh dev&quot; &#125; stage(&#x27;部署PaaS云消息队列服务&#x27;) &#123; sh &#x27;bash ./pipeline/buildImage.sh dev -queue&#x27; sh &#x27;bash ./pipeline/makesureImageReady.sh dev -queue&#x27; sh &quot;bash ./pipeline/deployImage.sh dev -queue&quot; sh &quot;bash ./pipeline/waitDeployment.sh dev -queue&quot; &#125; stage(&#x27;接口测试&#x27;) &#123; withEnv([&#x27;SERVICE_NAME=api-app&#x27;,&#x27;BACKEND_ADDR=&quot;http://devopsgroup-jbh-api-dev.haihangyun.com&quot;&#x27;]) &#123; dir(&#x27;api-test&#x27;) &#123; git url: &#x27;git@gitbj.haihangyun.com:JBH/api-doc.git&#x27; sh &#x27;npm run api-test&#x27; &#125; &#125; &#125; stage(&#x27;界面测试&#x27;) &#123; withEnv([&#x27;PATH=/opt/jdk1.7.0_67/bin:/usr/local/bin:$PATH&#x27;,&#x27;JAVA_HOME=/opt/jdk1.7.0_67&#x27;]) &#123; dir(&#x27;e2e-test&#x27;) &#123; git url: &#x27;git@gitbj.haihangyun.com:JBH/e2e-test.git&#x27; sh &#x27;mvn clean test&#x27; &#125; &#125; &#125; milestone() &#125; &#125;&#125; 而Mobile的流水线内容看起来是这样的： 12345678910111213141516171819202122232425262728293031withEnv([&#x27;PATH=/usr/local/bin:$PATH&#x27;]) &#123; node &#123; stage(&#x27;代码更新&#x27;) &#123; checkout scm: [$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;*/dev&#x27;]], userRemoteConfigs: [[url: &#x27;git@gitbj.haihangyun.com:JBH/app-android.git&#x27;]]] &#125; dir(&#x27;jbh&#x27;) &#123; stage(&#x27;单元测试&#x27;) &#123; sh &#x27;gradle clean test&#x27; &#125; stage(&#x27;代码检查&#x27;) &#123; sh &quot;sonar-scanner -Dsonar.login=&#x27;jenkins&#x27; -Dsonar.password=&#x27;jenkins&#x27; -Dsonar.host.url=http://sonar.haihangyun.com&quot; sh &quot;bash ./pipeline/checkSonarStatus.sh&quot; &#125; &#125; &#125; stage(&#x27;打包确认&#x27;) &#123; timeout(time:6, unit:&#x27;HOURS&#x27;) &#123; milestone() input &quot;生成此版本的Apk包？&quot; &#125; &#125; node &#123; dir(&#x27;jbh&#x27;) &#123; stage(&#x27;生成Apk&#x27;) &#123; sh &quot;gradle build&quot; archiveArtifacts &#x27;build/app.apk&#x27; &#125; &#125; &#125;&#125; ¶Jenkinsfile文件管理 依据Jenkins的惯例，流水线脚本文件通常命名为Jenkinsfile，与项目一起存放到版本仓库中。 在Jenkinsfile中可能还需要调用其他辅助脚本，我们可以将所有相关的文件放到一个统一的pipeline目录中。形成类似这样的结构： 12345678pipeline├── Jenkinsfile.dev├── Jenkinsfile.release├── Jenkinsfile.prod├── checkSonarStatus.sh├── buildImage.sh├── deployImage.sh├── ... ... ¶help Jenkins Step参考：https://jenkins.io/doc/pipeline/steps/ 使用Jenkins Syntax","raw":null,"content":null,"categories":[],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://blog.nicexiangcun.com/tags/jenkins/"}]},{"title":"代码整洁之道之装饰者模式","slug":"装饰者","date":"2017-04-23T13:15:08.000Z","updated":"2020-11-20T13:06:15.522Z","comments":true,"path":"2017/04/23/装饰者/","link":"","permalink":"http://blog.nicexiangcun.com/2017/04/23/%E8%A3%85%E9%A5%B0%E8%80%85/","excerpt":"装饰者模式（结构型设计模式）：通过动态的代理给一个对象添加一些额外的职责，就新增加的功能来说，装饰者比派生子类更加灵活。\n装饰者模式采用组合的构建方式,大大减少了类的数量,也打破了扩展功能一定要使用继承的思维惯性.但是装饰者模式会产生过多的小类,过度地使用会让程序变得更复杂\n\n如上图：WebService的renderData职责是返回String,现在需要添加两项职责：返回Xml 和 Json\n通过 RendererDecorator来代理 JsonRenderer 和 XmlRenderer  装饰Webservice 的返回结果。","text":"装饰者模式（结构型设计模式）：通过动态的代理给一个对象添加一些额外的职责，就新增加的功能来说，装饰者比派生子类更加灵活。 装饰者模式采用组合的构建方式,大大减少了类的数量,也打破了扩展功能一定要使用继承的思维惯性.但是装饰者模式会产生过多的小类,过度地使用会让程序变得更复杂 如上图：WebService的renderData职责是返回String,现在需要添加两项职责：返回Xml 和 Json 通过 RendererDecorator来代理 JsonRenderer 和 XmlRenderer 装饰Webservice 的返回结果。 ¶RenderableInterface 接口（被装饰者接口或者抽象类） 如下： 123456&lt;?phpnamespace DesignPatterns\\Structural\\Decorator;interface RenderableInterface&#123; public function renderData(): string;&#125; ¶Webservice（具体被装饰者） 如下： 1234567891011121314151617&lt;?phpnamespace DesignPatterns\\Structural\\Decorator;class Webservice implements RenderableInterface&#123; /** * @var string */ private $data; public function __construct(string $data) &#123; $this-&gt;data = $data; &#125; public function renderData(): string &#123; return $this-&gt;data; &#125;&#125; ¶RendererDecorator 代理如下(装饰者抽象类)： 1234567891011121314151617&lt;?phpnamespace DesignPatterns\\Structural\\Decorator;abstract class RendererDecorator&#123; /** * @var RenderableInterface */ protected $wrapped; /** * @param RenderableInterface $renderer */ public function __construct(RenderableInterface $renderer) &#123; $this-&gt;wrapped = $renderer; &#125;&#125; ¶具体装饰者 JsonRenderer 123456789&lt;?phpnamespace DesignPatterns\\Structural\\Decorator;class JsonRenderer extends RendererDecorator&#123; public function renderData(): string &#123; return json_encode($this-&gt;wrapped-&gt;renderData()); &#125;&#125; ¶具体装饰者 XmlRenderer 123456789101112&lt;?phpnamespace DesignPatterns\\Structural\\Decorator;class XmlRenderer extends RendererDecorator&#123; public function renderData(): string &#123; $doc = new \\DOMDocument(); $data = $this-&gt;wrapped-&gt;renderData(); $doc-&gt;appendChild($doc-&gt;createElement(&#x27;content&#x27;, $data)); return $doc-&gt;saveXML(); &#125;&#125; ¶test : 12345678910111213141516171819202122232425&lt;?phpnamespace DesignPatterns\\Structural\\Decorator\\Tests;use DesignPatterns\\Structural\\Decorator;use PHPUnit\\Framework\\TestCase;class DecoratorTest extends TestCase&#123; /** * @var Decorator\\Webservice */ private $service; protected function setUp() &#123; $this-&gt;service = new Decorator\\Webservice(&#x27;foobar&#x27;); &#125; public function testJsonDecorator() &#123; $service = new Decorator\\JsonRenderer($this-&gt;service); $this-&gt;assertEquals(&#x27;&quot;foobar&quot;&#x27;, $service-&gt;renderData()); &#125; public function testXmlDecorator() &#123; $service = new Decorator\\XmlRenderer($this-&gt;service); $this-&gt;assertXmlStringEqualsXmlString(&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;content&gt;foobar&lt;/content&gt;&#x27;, $service-&gt;renderData()); &#125;&#125; 备注：装饰者可以装饰，装饰者返回的结果。","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"swoole 安装","slug":"swoole-安装","date":"2017-04-19T14:59:56.000Z","updated":"2020-11-20T13:06:15.518Z","comments":true,"path":"2017/04/19/swoole-安装/","link":"","permalink":"http://blog.nicexiangcun.com/2017/04/19/swoole-%E5%AE%89%E8%A3%85/","excerpt":"¶从release上选择一个版本clone源代码 😉\nsudo  git clone https://github.com/swoole/swoole-src.git\n¶编译生成configure文件\n一 ： 通过phpize脚本生成\ncd swoole-src.git\nsudo /usr/bin/phpize7.0\n如果没有找到phpize 先安装phpize\n123sudo apt-get install autoconf automake libtool m4sudo apt-get install php7.0-devFor PHP7.1, use php7.1-dev","text":"¶从release上选择一个版本clone源代码 😉 sudo git clone https://github.com/swoole/swoole-src.git ¶编译生成configure文件 一 ： 通过phpize脚本生成 cd swoole-src.git sudo /usr/bin/phpize7.0 如果没有找到phpize 先安装phpize 123sudo apt-get install autoconf automake libtool m4sudo apt-get install php7.0-devFor PHP7.1, use php7.1-dev 二 ： 通过configure生成makefile 文件 1sudo ./configure 三 ：通过 makefile 文件编译生成 .so文件 123sudo makesudo make test //可选sudo make install 四 ：配置 .ini 123456789101112cd /etc/php/7.0/mods-available/touch swoole.iniextension=swoole.sosudo ln -s /etc/php/7.0/mods-available/swoole.ini/etc/php/7.0/cli/conf.d/swoole.inisudo ln -s /etc/php/7.0/mods-available/swoole.ini/etc/php/7.0/fpm/conf.d/swoole.ini//fpm模式下需要重启fpm，phpinfo 查看sudo service php7.0-fpm restartphp -m | grep swoole ¶通过Cmake安装 把swoole.so做为一个C库","raw":null,"content":null,"categories":[{"name":"swoole","slug":"swoole","permalink":"http://blog.nicexiangcun.com/categories/swoole/"}],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://blog.nicexiangcun.com/tags/swoole/"}]},{"title":"大型网站技术篇之负载均衡","slug":"large-website-load-balance","date":"2017-04-17T14:03:03.000Z","updated":"2020-11-20T13:06:15.513Z","comments":true,"path":"2017/04/17/large-website-load-balance/","link":"","permalink":"http://blog.nicexiangcun.com/2017/04/17/large-website-load-balance/","excerpt":"","text":"¶架构图 ¶负载均衡工作方式 ¶http 重定向＝》转移请求 ¶DNS 负载均衡 多机房部署，就近访问。可以查看google的dns配置 ： dig google.cn 可以产看 google.cn 的域名后面配置的IP ¶反响代理负载均衡 工作在 http层（七层）常用 nginx做代理软件 ¶IP负载均衡 工作在 传输层 (四层转发负载) ，通过转发ip数据包方式，缺点是所有数据均要通过负载机器，负载机器的网络带宽会逐渐成为瓶颈 ¶LVS 工作在 数据链路层（二层）通过虚拟IP转发webserver,2⃣webserver处理完成后直接响应给客户端 ¶负载均衡常见策略 轮询 加权轮询 最小链接数 ip hash","raw":null,"content":null,"categories":[],"tags":[{"name":"大型网站","slug":"大型网站","permalink":"http://blog.nicexiangcun.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/"}]},{"title":"mysql锁机制","slug":"mysql","date":"2017-04-11T11:01:18.000Z","updated":"2020-11-20T13:06:15.514Z","comments":true,"path":"2017/04/11/mysql/","link":"","permalink":"http://blog.nicexiangcun.com/2017/04/11/mysql/","excerpt":"锁机制用于管理对共享资源的并发访问，提供数据的完整性和一致性\n\n读锁是共享的，不影响并发的读取，但是会阻塞写操作（当然这只是默认情况，可以通过修改配置，使其可以进行末尾插入），写锁是排他的，阻塞读和写。\n\n¶行锁\nInnoDB行锁是通过给索引记录加锁来实现的，即：InnoDB会在它扫描到的每条索引记录上设置一个S或X锁，在MVCC模式下，简单的select语句不会加任何锁，除非手动添加。因此查询时，索引很重要 💯\n¶锁模式\n共享锁S(Shared Lock)： 允许事务使用该锁去读取\n加锁语句： select … lock in share mode (手动加锁)\n排它锁X(Exclusive Lock)： 允许事务使用该锁去update、insert或者delete\n加锁语句： insert … update … delete … select … for update (手动加锁)\n¶阻塞\n因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一事务中的锁释放它所占有的资源，阻塞可以确保事务正常进行\n¶死锁\n指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象 除了超时机制外（innodb_lock_wait_timeout），InnoDB还采用了wait-for graph来进行死锁检测，若检测到死锁，InnoDB会选择回滚undo量最小的事务","text":"锁机制用于管理对共享资源的并发访问，提供数据的完整性和一致性 读锁是共享的，不影响并发的读取，但是会阻塞写操作（当然这只是默认情况，可以通过修改配置，使其可以进行末尾插入），写锁是排他的，阻塞读和写。 ¶行锁 InnoDB行锁是通过给索引记录加锁来实现的，即：InnoDB会在它扫描到的每条索引记录上设置一个S或X锁，在MVCC模式下，简单的select语句不会加任何锁，除非手动添加。因此查询时，索引很重要 💯 ¶锁模式 共享锁S(Shared Lock)： 允许事务使用该锁去读取 加锁语句： select … lock in share mode (手动加锁) 排它锁X(Exclusive Lock)： 允许事务使用该锁去update、insert或者delete 加锁语句： insert … update … delete … select … for update (手动加锁) ¶阻塞 因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一事务中的锁释放它所占有的资源，阻塞可以确保事务正常进行 ¶死锁 指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象 除了超时机制外（innodb_lock_wait_timeout），InnoDB还采用了wait-for graph来进行死锁检测，若检测到死锁，InnoDB会选择回滚undo量最小的事务 ¶更新丢失 由于并发问题，在事务内部未正确使用锁定导致的更新丢失问题 zhangshan --&gt; money = 20 Session A SessionB begin 查询money = 20 select money from account where user=‘zhangshan’; &lt;br&gt; |begin;&lt;br&gt;查询money = 20&lt;br&gt;select money from account where user='zhangshan';&lt;br&gt; update account set money=money+10 where user=‘zhangshan’;commit; | | update account set money=money+50 where user=‘zhangshan’;commit; 最终的结果是：70，少加10 解决办法： select … for update 锁定该条记录，加排它锁 Session A SessionB begin对该条记录加排它锁X查询money = 20select money from account where user=‘zhangshan’ for update; &lt;br&gt; |begin;&lt;br&gt;被阻塞，程序挂起，等待Session A完成&lt;br&gt;查询money = 20&lt;br&gt;select money from account where user='zhangshan' for update;&lt;br&gt; update account set money=money+10 where user=‘zhangshan’;commit; | |update account set money=money+50 where user=‘zhangshan’;commit; ¶死锁产生的2种情况 123456 CREATE TABLE b ( id int(11) NOT NULL, uid int(11) DEFAULT NULL, PRIMARY KEY (id), KEY uid (uid)) ENGINE=InnoDB DEFAULT CHARSET=utf8 id uid 1 10 2 20 3 30 4 40 ¶第一种情况：区间死锁（目前最多的情况） Session A SessionB begin;使用辅助索引筛选时，此时使用Next-key算法锁定区间为:(11,55)select * from b where uid=22 for update; &lt;br&gt; |begin;&lt;br&gt;此时Session B被阻塞&lt;br&gt;select * from b where uid&lt;22 for update;&lt;br&gt; 插入成功…insert into b values(9,20);commit; | |死锁出现Deadlock found，try restarting transactionrollback; ¶第二种情况：不同记录锁定 Session A SessionB begin;id为主键，使用Record Lock算法锁定锁定id=5该行记录select * from b where id = 5 for update; &lt;br&gt; |begin;&lt;br&gt;同理&lt;br&gt;select * from b where id=8 for update;&lt;br&gt; select * from b where id = 8 for update; | |死锁出现select * from b where id=5 for update;Deadlock found，try restarting transaction; commit | | rollback; ¶如何避免阻塞和死锁： update时，尽量使用主键或辅助索引作为where条件，切勿不使用索引进行查询，否则全表锁定 跑脚本或者批量任务时，每次只对一条数据加事务处理，切勿将一个大循环包裹在一个事务里面 严禁在update语句里面封装子查询，select语句，update … set … where …就ok，其他的由程序处理 养成良好的事务习惯，事务一定要进行commit或rollback操作 涉及到修改同一张表数据的定时任务，应该间隔一定的时间，避免出现死锁 减少锁定范围，在跑定时任务时，筛选数据时，尤其是日期范围的，请务必使用between … and … 而不是end_time &lt; now() ¶隐式转换 查询时，类型不对，导致类型转换，结果不对 mysql&gt; select * from test_2 where name=0; id name 1 | lhw 2 | cxx 3 | 0 分析：很多开发在书写sql时，没有考虑到传入到数据库的值的类型，比如：上面name类型为char，而传入查询时，却输入的是0，而不是’0’ 结果：mysql对匹配到行的字符串进行了类型转换，发现转换非法，转换成了0 注意：在查询时检查传入的查询条件类型 全表扫描，查询慢 mysql&gt; explain select * from xboss_account where mobile=15510337665; 分析：mobile字段类型为char(11)，查询时，应该使用mobile=‘15510337665’ 注意：在php端书写sql时，应正确传入查询值的类型 正确使用类型转换，防止SQL注入，其它的类型转换，感兴趣的可以自己研究，如：select '11aa' + 11,select a+1，select '1'+1等","raw":null,"content":null,"categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.nicexiangcun.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.nicexiangcun.com/tags/mysql/"}]},{"title":"关于Mysql的一些总结","slug":"Mysql-总结","date":"2017-04-10T13:34:15.000Z","updated":"2020-11-20T13:06:15.509Z","comments":true,"path":"2017/04/10/Mysql-总结/","link":"","permalink":"http://blog.nicexiangcun.com/2017/04/10/Mysql-%E6%80%BB%E7%BB%93/","excerpt":"🐛\n¶事务概念：\n事务是由一组SQL组成，可以认为是一个执行单元，在事务中，所有操作要么全部成功，要么全部回滚，建表统一使用InnoDB存储引擎\n\n¶事务的ACID的特性：\n原子性(atomicity): 事务中的所有操作要么全部提交成功，要么全部失败回滚一致性(consistency): 在事务开始和完成时，数据都必须保持一致状态隔离性(isolation): 一个事务所做的修改在提交之前对其它事务是不可见的持久性(durability):一旦事务提交，其所做的修改便会永久保存在数据库中\n\n¶事务使用场景：\n例如一个金融平台，凡是涉及到核心业务，比如：金额、积分等操作都必须使用事务，事务保证了数据的一致性和完整性\n比如用户购买，此时需要使用事务，同时需要使用select … for update进行数据验证，确保数据的一致性和完整性\n\n¶不需要使用事务的场景：\n用户登录\n用户资产，钱包，积分等查询，允许一定的延时\n凡是不涉及到交易的查询\n\n¶NULL的问题\nNULL：可以插入空值或NULL，NULL会占用数据库空间，数据库会请求额外的空间记录该行为NULL\nNOT NULL：不可以插入NULL，可以插入空值，空值不占用数据库空间\nNULL占用空间，空值不占用空间，B树索引不会存储NULL值，如果索引字段可以为NULL，则效率下降很多\n通常字段设置(NOT NULL) 如时间字段 NOT NULL DEFAULT 0000-00 00:00:00","text":"🐛 ¶事务概念： 事务是由一组SQL组成，可以认为是一个执行单元，在事务中，所有操作要么全部成功，要么全部回滚，建表统一使用InnoDB存储引擎 ¶事务的ACID的特性： 原子性(atomicity): 事务中的所有操作要么全部提交成功，要么全部失败回滚一致性(consistency): 在事务开始和完成时，数据都必须保持一致状态隔离性(isolation): 一个事务所做的修改在提交之前对其它事务是不可见的持久性(durability):一旦事务提交，其所做的修改便会永久保存在数据库中 ¶事务使用场景： 例如一个金融平台，凡是涉及到核心业务，比如：金额、积分等操作都必须使用事务，事务保证了数据的一致性和完整性 比如用户购买，此时需要使用事务，同时需要使用select … for update进行数据验证，确保数据的一致性和完整性 ¶不需要使用事务的场景： 用户登录 用户资产，钱包，积分等查询，允许一定的延时 凡是不涉及到交易的查询 ¶NULL的问题 NULL：可以插入空值或NULL，NULL会占用数据库空间，数据库会请求额外的空间记录该行为NULL NOT NULL：不可以插入NULL，可以插入空值，空值不占用数据库空间 NULL占用空间，空值不占用空间，B树索引不会存储NULL值，如果索引字段可以为NULL，则效率下降很多 通常字段设置(NOT NULL) 如时间字段 NOT NULL DEFAULT 0000-00 00:00:00 任何数值的运算和字符组合，结果都是NULL mysql&gt; select 1+NULL, CONCAT('Invisible',NULL); 1+NULL CONCAT(‘Invisible’,NULL) NUL NULL NULL允许插入和NULL，查询时容易产生歧义 mysql&gt; select * from test_1 where name &lt;&gt; ; id name 1 lhw mysql&gt; select * from test_1 where name is not null; id name 1 lhw 2 count问题，忽略非主键外的null值 mysql&gt; select count(1),count(name) from test_1; count(1) count(name) 6 3 排序问题 在order by排序的时候，如果存在NULL值，那么NULL是最小的，ASC正序排序的话，NULL值是在最前面的 mysql&gt; select * from test_1 order by name asc; id name create_at 3 null null 2 null 5 lhw null 解决办法： 12select * from test_1 order by isnull(name) asc;select *,name is null as username from test_1 order by username asc; ¶流控制函数 ¶case语法： 12345CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result ...] [ELSE result] END&lt;=等价于=&gt;CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END ¶if语法： 1234IF(expr1,expr2,expr3)如果expr1为True，返回expr2，否则返回expr3 ¶ifnull语法： 1234IFNULL(expr1,expr2)如果expr1为null，返回expr2 ¶nullif语法： 1234NULLIF(expr1,expr2)如果expr1=expr2，返回null，否则返回expr1 ¶隐式转换 查询时，类型不对，导致类型转换，结果不对 mysql&gt; select * from test_2 where name=0; id name 1 lhw 2 cxx 3 0 分析：很多开发在书写sql时，没有考虑到传入到数据库的值的类型，比如：上面name类型为char，而传入查询时，却输入的是0，而不是’0’ 结果：mysql对匹配到行的字符串进行了类型转换，发现转换非法，转换成了0 注意：在查询时检查传入的查询条件类型 全表扫描，查询慢 mysql&gt; explain select * from xboss_account where mobile=15510337665; 分析：mobile字段类型为char(11)，查询时，应该使用mobile=‘15510337665’ 注意：在php端书写sql时，应正确传入查询值的类型 正确使用类型转换，防止SQL注入，其它的类型转换，感兴趣的可以自己研究，如：select ‘11aa’ + 11,select a+1，select ‘1’+1等 ¶Group by group by一般和聚合函数一起使用才有意义，在MySQL5.7引入了ONLY_FULL_GROUP_BY对语法合法性进行检测 使用group by的两个要素： 出现在select后面的字段，要么是聚合函数中的，要么就是group by中的，若是该字段既不出现在聚合函数中，也不出现在后面的group by中，则该条select语句是错误的 若是需要筛选结果，可以先使用where，再用group by；或者先用group by，再用having 为什么要求使用聚合函数： 在未使用聚合函数的情况下，如果group by后面的字段不唯一，则会出现查询出来的数据不对 ¶Sql mode问题 sql_mode通过检测sql的合法性来保证数据的一致性 常用到的设置： STRICT_TRANS_TABLES 如果不能将给定的值插入到事务表中，则放弃该语句，对于非事务表，如果出现在单行语句或多行语句的第一行，则放弃该语句 NO_ENGINE_SUBSTITUTION 当使用create table或者alter table时，自动控制替换存储引擎 ONLY_FULL_GROUP_BY 实现sql语句合法性检测 对于group by column表达式，select列必须使用聚合函数，否则报错，如： select group_concat(id1),id2 from test_1 group by id2; ¶没有开启严格模式，引起的问题： 一 比如：freeze_score不为负数，即：unsigned update xboss_integrals set freeze_score = 500-1000, updated_at = ‘2016-07-04 16:51:20’ where id = ‘562’; 此时freeze_score会被设置为0，warning警告不会被返回给api端，导致数据不一致 二 比如：mobile字段为int(11) update zz set phone=‘188qwewq’ where id=8; 此时phone字段会被设置为188，warning警告不会被返回给api端，导致数据不一致 ¶JOIN语法 此处只说MySQL最常用的两种join类型，inner join 和 {LEFT|RIGHT} [OUTER] join 在MySQL中的JOIN，CROSS JOIN和INNER JOIN和’,'在句法上相同,可以互相替换使用。但是在标准的SQL中，它们是不同的 inner join(内连接)： 将A表和B表中存在连接关系的字段，组成的结果集(A表和B表的交集) left join(左连接,属于外连接): 以左表为准，去右表找数据，如果没有匹配的数据，则以null补位右表的数据，所以输出结果数为左表原数据集(right join同理) tips：left join 可以转换为 inner join 123select * from a inner join b on a.id=b.id;&lt;==&gt;select * from a left join b on a.id=b.id where b.id is not null; ¶常用字符处理函数 concat(str1,str2,...) 把给定字符串合并为一个字符串,适用于多个数据列 select concat(firstname,lastname) as fullname from user; concat_ws(separator,str1,str2,...) 使用指定的分隔符将给定的字符串或列合并为一个字符串 select concat_ws('-',id,name) from pp; ELT(N,str1,str2,str3,...) 返回字符串列表的第几个元素，当N为1时，返回str1，为2时，返回str2，当N大于字符串列表长度时，返回NULL select elt(2,'hello','world'); –&gt;world SUBSTRING(str,pos),SUBSTRING(strFROMpos),SUBSTRING(str,pos,len), SUBSTRING(str FROM pos FOR len) 截取字符串，默认起始位置为1，结束位置为-1 从第五个字符开始截取 SELECT SUBSTRING('Quadratically',5); –&gt;ratically 从第四个字符开始截取 SELECT SUBSTRING('foobarbar' FROM 4); –&gt;barbar 从第五个字符开始截取，截取长度为6个字符 SELECT SUBSTRING('Quadratically',5,6); –&gt;ratica 从倒数第三个字符截取 SELECT SUBSTRING('Sakila', -3); –&gt;ila 从倒数第4个字符开始，截取长度为2个字符 SELECT SUBSTRING('Sakila' FROM -4 FOR 2); –&gt;ki substring_index(str,delim,count) 截取字符串，substring_index('www.mysql.com','.',2)，以逗号分隔，截取：www.mysql select substring_index(sitename,'.',-2) from siteinfo where id=2; 截取结果为:mysql.com mid(str,pos,len)截取字符串,mid('helloworld',7,12)，截取第7个到第12个字符之间的字符串，结果为：world select mid(username,6,5) from userinfo; left(str,len)&lt;=&gt;right(str,len) 截取字符串，left('hello world',5)，截取左边5个字符 select right(username,5) from userinfo; replace(str,from_str,to_str) 替换字符串 将username列中的zhang姓全部改为li姓 update user set username=replace(username,'zhang','li'); instr(str,substr) 返回指定字符在字符串中的位置，instr('welcome you baby,','you'),返回位置为：9 select instr(username,'shan') as pos from userinfo where uid=1; find_in_set(str,strlist) 返回字符串在字符串列表中的位置，字符串列表必须以逗号’,'分隔，起始值为：1 select find_in_set('shi','wo,shi,chinese') as pos; 返回值为2 TRIM([&#123;BOTH | LEADING | TRAILING&#125; [remstr] FROM] str), TRIM([remstr FROM] str) 移除指定的字符，both表示前后，leading：前面，trailing：后面 移除字符串前后的空格，如果不指定，默认为both，移除空格 select trim(' bar '); –&gt;bar 移除字符串前面的x SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx'); –&gt;barxxx 移除字符串中的x SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx'); –&gt;bar 移除字符串后面的xyz SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz'); –&gt;barx ¶常用时间函数 CURDATE(),CURTIME() 以’YYYY-MM-DD’格式返回当前日期 select curdate(); –&gt;2016-07-05 以’YYYYMMDD’格式返回当前日期，+0表示+0天 select curdate()+0; –&gt;20160705 以’HH:MM:SS’格式返回当前时间 select curtime(); –&gt;15:17:30 以’HHMMSS’格式返回当前时间,+0表示+0秒 select curtime()+0; –&gt;151855 DATE(),TIME() 返回时间表达式的日期部分 select date(now()); –&gt;2016-07-05 返回时间表达式的时间部分 select time(now()); –&gt;15:14:16 DATEDIFF(expr1,expr2),TIMEDIFF(expr1,expr2) 返回expr1-expr2相差的天数，忽略时间部分 select datediff(now(),‘2016-6-12 12:00:00’); –&gt;23 返回expr1-expr2相差的时间 select timediff(now(),‘2016-6-12 12:00:00’); –&gt;555:24:52 FROM_UNIXTIME(unix_timestamp),FROM_UNIXTIME(unix_timestamp,format) 格式化unix时间戳成’YYYY-MM-DD HH:MM:SS’ or YYYYMMDDHHMMSS格式 select from_unixtime(1467703739,‘%Y %M %D %h:%i:%s’) –&gt;2016 July 5th 03:28:59 select from_unixtime(1467703739); –&gt;2016-07-05 15:28:59 TIMESTAMP(expr),TIMESTAMP(expr1,expr2) 当一个参数时，格式化为datetime类型，当为2个参数时，expr2将会对expr1的日期或时间部分进行相加 select timestamp(‘2016-07-03’); –&gt;2016-07-03 00:00:00 SELECT TIMESTAMP(‘2003-12-31 12:00:00’,‘09:00:00’); –&gt;2003-12-31 21:00:00 UNIX_TIMESTAMP()返回unix时间戳 select unix_timestamp(‘2015-08-12 13:57:51’); –&gt;1439359071 DATE_FORMAT(date,format)，TIME_FORMAT(time,format) 格式化date成指定类型 select date_format(now(),‘%Y-%m-%d’); –&gt;2016-07-05 DATE_ADD(date,INTERVAL expr unit), DATE_SUB(date,INTERVAL expr unit) 时间加减 加10分钟 select date_add(now(), interval 10 minute); –&gt;2016-07-05 15:57:17 减10分钟 select date_sub(now(), interval 10 minute); –&gt;2016-07-05 15:37:47 设置时间为24小时之前 set @time_before_24= (select date_sub(now(),interval 24 hour)); ¶架构组件 ¶MaxScale 自动读写分离 自动剔除延迟超过30s的从库 读负载 最小化宕机时间 ¶MHA 自动故障探测，恢复 差异日志应用，保证数据一致性 ¶Pacemaker + Corosync 提供心跳检测和自动故障切换，保证MaxScale的高可用 ¶Box Anemometer 慢查询分析系统，每5分钟自动采集慢查询日志并汇总 ¶Binlog Server 负责中继Binlog，并加密复制给海口机房 ¶数据安全 ¶数据审核 明御数据库审计与风险控制系统提供准实时的数据操作审核记录 ¶数据备份 每天全量备份并加密 每天单表备份并加密 实时binlog增量备份 灾备系统 ¶Sphinx ¶规范 手机号：长度&gt;=7个字符 姓名：长度&gt;=2个字符 模糊查询结果统一最大取1W：limit=10000,maxmatches=10000 表：xboss_sphinx_counts 解决后台分页（包含where条件的count，请直接去原库查询），例句： select count(*) from xboss_account; 已支持表： xboss_account,xboss_user_orders 例子（需要对xboss_account表进行count，并计算后台显示页数）： select table_rows from xboss_sphinx_counts where query='*xboss_account*'; xboss_account必须跟上*号 表：xboss_account_sphinx 解决模糊查询和模糊join查询： 索引xboss_account表的true_name，mobile字段 ¶SphinxSE SQL语法： 语法：limit,offet,maxmatches limit默认为20，offset默认为0，maxmatches默认为1000（rows） 例子： 1234567select * from xboss_account_sphinx where query=&#x27;*18810*;limit=2000;maxmatches=100&#x27;;--&gt;输出100行结果select * from xboss_account_sphinx where query=&#x27;*18810*;limit=2000&#x27;;--&gt;输出1000行结果 引用索引字段 '@'引用索引字段,如：@mobile，@true_name，| 表示 and，必须加上：mode=extended 如果没有指定，则检索所有的索引字段 下面查询true_name包含‘付’，且手机号包含‘18622’的用户 1select b.true_name,b.mobile from xboss_account_sphinx a join xboss_account b on a.uid=b.uid where b.is_auth=&#x27;1&#x27; and a.query=&#x27;@mobile *18622* | @true_name *付*;mode=extended;limit=10000;maxmatches=10000&#x27; limit 15 offset 0; filter filter 只支持int类型 采用filter=字段名称,值就相当于where中的字段名=值，filter提到的字段必须在sphinx的source部分的字段属性定义中定义 例句：查询is_auth为1的用户，不等于：!filter=is_auth,1，范围：filter=is_auth,1,2,3 1select b.true_name,b.mobile,b.created_at,b.updated_at from xboss_account_sphinx a join xboss_account b on a.uid=b.uid where a.query=&#x27;@mobile *18622* | @true_name *付*;mode=extended;limit=10000;maxmatches=10000;filter=is_auth,1&#x27; order by b.created_at limit 15 offset 0; ¶分页（在外部实现） 1select a.*,b.mobile,b.true_name from xboss_wallet_records a join xboss_account b join xboss_account_sphinx c on a.uid = b.uid and a.uid = c.uid where a.`type_new` != &#x27;4&#x27; and c.query=&#x27;*1881048*;limit=10000;maxmatches=10000&#x27; order by a.id desc limit 15 offset 0; ¶and或or查询 and查询，用|分隔 123set names utf8;select * from xboss_account_sphinx a join xboss_wallet_records b on a.uid=b.uid where a.query=&#x27;@mobile *18622* | @true_name *付*;mode=extended;limit=10000;maxmatches=10000&#x27;\\G; ¶or查询 1select b.username from xboss_account_sphinx a join xboss_wallet_records b on a.uid=b.uid where a.query =&#x27;*1881048*;limit=10000;maxmatches=10000&#x27; or a.query=&#x27;*付*;limit=10000;maxmatches=10000&#x27;\\G;","raw":null,"content":null,"categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.nicexiangcun.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.nicexiangcun.com/tags/mysql/"}]},{"title":"命令行下mysql事务控制方法","slug":"Mysql-item-事务","date":"2017-04-10T13:18:02.000Z","updated":"2020-11-20T13:06:15.509Z","comments":true,"path":"2017/04/10/Mysql-item-事务/","link":"","permalink":"http://blog.nicexiangcun.com/2017/04/10/Mysql-item-%E4%BA%8B%E5%8A%A1/","excerpt":"查看mysql系统的事务隔离级别 ☺️\n12345678mysql&gt; SELECT @@global.tx_isolation;+-----------------------+| @@global.tx_isolation |+-----------------------+| REPEATABLE-READ       |+-----------------------+1 row in set (0.00 sec)\n查看mysql会话的事务隔离级别\n123456789101112131415mysql&gt; SELECT @@tx_isolation;+-----------------+| @@tx_isolation  |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.00 sec)mysql&gt; SELECT @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| REPEATABLE-READ        |+------------------------+1 row in set (0.00 sec)","text":"查看mysql系统的事务隔离级别 ☺️ 12345678mysql&gt; SELECT @@global.tx_isolation;+-----------------------+| @@global.tx_isolation |+-----------------------+| REPEATABLE-READ |+-----------------------+1 row in set (0.00 sec) 查看mysql会话的事务隔离级别 123456789101112131415mysql&gt; SELECT @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.00 sec)mysql&gt; SELECT @@session.tx_isolation;+------------------------+| @@session.tx_isolation |+------------------------+| REPEATABLE-READ |+------------------------+1 row in set (0.00 sec) 设置系统的事务隔离级别 123456789101112131415161718mysql&gt; set global transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @@global.tx_isolation;+-----------------------+| @@global.tx_isolation |+-----------------------+| READ-COMMITTED |+-----------------------+1 row in set (0.00 sec)mysql&gt; SELECT @@tx_isolation;+-----------------+| @@tx_isolation |+-----------------+| REPEATABLE-READ |+-----------------+1 row in set (0.00 sec) 设置会话的事务隔离级别 12345678910111213141516171819mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @@global.tx_isolation;+-----------------------+| @@global.tx_isolation |+-----------------------+| READ-COMMITTED |+-----------------------+1 row in set (0.00 sec)mysql&gt; SELECT @@tx_isolation;+----------------+| @@tx_isolation |+----------------+| READ-COMMITTED |+----------------+1 row in set (0.00 sec) mysql默认是自动提交事务的，查看autocommit变量 12345678mysql&gt; select @@autocommit;+--------------+| @@autocommit |+--------------+| 1 |+--------------+1 row in set (0.01 sec) 设置mysql不自动提交事务 12345678910mysql&gt; set autocommit = 0;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@autocommit;+--------------+| @@autocommit |+--------------+| 0 |+--------------+1 row in set (0.01 sec) 使用rollback回滚事务 123456789101112131415161718192021mysql&gt; select * from t1;Empty set (0.00 sec)mysql&gt; insert into t1 values (51, 3000);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+----+------+| a | b |+----+------+| 51 | 3000 |+----+------+1 row in set (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.03 sec)mysql&gt; select * from t1;Empty set (0.00 sec)mysql&gt; 使用start transaction;或begin;显示的开启一个事务 1234567891011121314151617181920212223242526272829mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t1 values (51, 3000);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+----+------+| a | b |+----+------+| 51 | 3000 |+----+------+1 row in set (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.04 sec)mysql&gt; select * from t1;Empty set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from t1;Empty set (0.00 sec) 使用savepoint在事务中创建一个保存点（可以在一个事务中创建多个保存点） 12345678910111213141516171819202122232425262728293031323334353637383940414243mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t1 values (51, 3000);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+----+------+| a | b |+----+------+| 51 | 3000 |+----+------+1 row in set (0.00 sec)mysql&gt; savepoint tx1;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t1 values (52, 3000);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+----+------+| a | b |+----+------+| 51 | 3000 || 52 | 3000 |+----+------+2 rows in set (0.00 sec)mysql&gt; rollback to tx1;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from t1;+----+------+| a | b |+----+------+| 51 | 3000 |+----+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.04 sec) 以上是mysql命令行是对事务隔离级别和事务提交的基本操作。现在说明以下操作基于可重复复读的隔离级别，事务不自动提交。 12345678mysql&gt; set global transaction isolation level repeatable read;Query OK, 0 rows affected (0.00 sec)mysql&gt; set session transaction isolation level repeatable read;Query OK, 0 rows affected (0.00 sec)mysql&gt; set autocommit = 0;Query OK, 0 rows affected (0.00 sec)","raw":null,"content":null,"categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.nicexiangcun.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.nicexiangcun.com/tags/mysql/"}]},{"title":"Java 变量和数据类型","slug":"java-数据类型","date":"2017-04-10T12:58:51.000Z","updated":"2020-11-20T13:06:15.512Z","comments":true,"path":"2017/04/10/java-数据类型/","link":"","permalink":"http://blog.nicexiangcun.com/2017/04/10/java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"¶变量 😜\n\n变量可以持有基本类型或指向某个对象\n变量必须先定义后使用\n定义变量\n变量可以被赋值，还可以被重新赋值\n等号=是赋值，不是数学的相等\n\n¶Eclipse Debug\n进入调试模式后可以设置断点后单步执行\n¶数据类型\n\n整数类型：byte，short，int，long\n浮点类型：float，double\n字符类型：char\n布尔类型：boolean\n\n¶常量\n\n用final定义\n通常全部大写\n避免magic number\n\n¶计算机内存地址\n如下图所示，每个内存正好存一个字节，算一下如果你有16G内存，大概有多少字节呢.\n\njava中,整型所对应内存的字节数如下图\n\n¶整型的范围\njava 的整型是带符号的，注意要声明为long整型的时候要在后面加上L，否则是int类型，如下图\n","text":"¶变量 😜 变量可以持有基本类型或指向某个对象 变量必须先定义后使用 定义变量 变量可以被赋值，还可以被重新赋值 等号=是赋值，不是数学的相等 ¶Eclipse Debug 进入调试模式后可以设置断点后单步执行 ¶数据类型 整数类型：byte，short，int，long 浮点类型：float，double 字符类型：char 布尔类型：boolean ¶常量 用final定义 通常全部大写 避免magic number ¶计算机内存地址 如下图所示，每个内存正好存一个字节，算一下如果你有16G内存，大概有多少字节呢. java中,整型所对应内存的字节数如下图 ¶整型的范围 java 的整型是带符号的，注意要声明为long整型的时候要在后面加上L，否则是int类型，如下图 ¶浮点数 12float money = 100.12f // 结尾加fdouble d = 1.79e4 ¶字符类型 注意字符类型和字符串类型的区别：字符类型用单引号，并且只有一个字符。 12char c = &#x27;a&#x27; ;char b = &#x27;李&#x27;； ¶二进制和十六进制表示整形的方式 123int i3 = 2_000_000_000;int i4 = 0xff0000; // 十六进制表示的十进制16711680int i5 = 0b1000000000; // 二进制表示的十进制512 如果要输出一个以16进制表示的整型，或者以二进制表示的整型，可以使用JDK提供的方法： 123456// 输出以十六进制表示的整型的字符串：System.out.println(Integer.toHexString(12345678)); // bc614e// 输出以二进制表示的整型的字符串：System.out.println(Integer.toBinaryString(12345678)); // 101111000110000101001110 ¶常量 不管PHP 还是 JAVA,许多可以避免硬编码的地方都可以用常亮去修饰，这样可以使我们更好地去理解程序的意图 1final double PI = 3.14","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://blog.nicexiangcun.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.nicexiangcun.com/tags/Java/"}]},{"title":"大型网站技术篇之容量估算和负载的查看","slug":"large-website","date":"2017-04-09T12:29:31.000Z","updated":"2020-11-20T13:06:15.513Z","comments":true,"path":"2017/04/09/large-website/","link":"","permalink":"http://blog.nicexiangcun.com/2017/04/09/large-website/","excerpt":"¶✍️大型网站具有的特点\n\n海量数据（大数据）\n高并发 大流量\n高可用 7*24 小时不断服务, 五个9级别 (99.999)\n频频迭代，需求多\n\n¶✍️容量估算和负载查看\n容量：数据量，并发量，带宽，CPU 等\n容量评估的简单步骤和方法：\n\n评估总访问量，结合市场及运营活动等评估\n评估平局访问量QPS\n评估高峰QPS，一般是平均QPS的2倍\n系统压测如用apache的 ab等，单机极限QPS，拿高峰的QPS和单机压测的QPS比对一下。\n计算容量\n\n负载：系统的繁忙程度，即有多少进程等cpu调度\ntop命令：过去1分钟，5分钟，10分钟的负载值\nLoad Avg: 1.61, 1.79, 1.64  CPU usage: 1.96% user, 1.96% sys, 96.6%\nLoad 的警惕值 ： 以单核为例 Load &gt; 2 系统以相对繁忙 Load &gt; 5 系统崩溃边缘","text":"¶✍️大型网站具有的特点 海量数据（大数据） 高并发 大流量 高可用 7*24 小时不断服务, 五个9级别 (99.999) 频频迭代，需求多 ¶✍️容量估算和负载查看 容量：数据量，并发量，带宽，CPU 等 容量评估的简单步骤和方法： 评估总访问量，结合市场及运营活动等评估 评估平局访问量QPS 评估高峰QPS，一般是平均QPS的2倍 系统压测如用apache的 ab等，单机极限QPS，拿高峰的QPS和单机压测的QPS比对一下。 计算容量 负载：系统的繁忙程度，即有多少进程等cpu调度 top命令：过去1分钟，5分钟，10分钟的负载值 Load Avg: 1.61, 1.79, 1.64 CPU usage: 1.96% user, 1.96% sys, 96.6% Load 的警惕值 ： 以单核为例 Load &gt; 2 系统以相对繁忙 Load &gt; 5 系统崩溃边缘","raw":null,"content":null,"categories":[],"tags":[{"name":"大型网站","slug":"大型网站","permalink":"http://blog.nicexiangcun.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/"}]},{"title":"Yar","slug":"Yar","date":"2017-03-27T14:57:58.000Z","updated":"2020-11-20T13:06:15.509Z","comments":true,"path":"2017/03/27/Yar/","link":"","permalink":"http://blog.nicexiangcun.com/2017/03/27/Yar/","excerpt":"¶🐷 Yar 编译安装\n123456789101112131415161718192021222324git clone https://github.com/laruence/yar.gitcd yar//安装依赖包sudo apt-get install curlsudo apt-get install libcurl4-gnutls-dev//软连接到bin目录ln -s /usr/local/php7.0/bin/phpize /usr/bin/phpize phpize./configuresudo makesudo make install//配置fpmsudo ln -s /etc/php/7.0/mods-available/yar.ini  /etc/php/7.0/fpm/conf.d/yar.ini//重启fpmsudo service php7.0-fpm restart","text":"¶🐷 Yar 编译安装 123456789101112131415161718192021222324git clone https://github.com/laruence/yar.gitcd yar//安装依赖包sudo apt-get install curlsudo apt-get install libcurl4-gnutls-dev//软连接到bin目录ln -s /usr/local/php7.0/bin/phpize /usr/bin/phpize phpize./configuresudo makesudo make install//配置fpmsudo ln -s /etc/php/7.0/mods-available/yar.ini /etc/php/7.0/fpm/conf.d/yar.ini//重启fpmsudo service php7.0-fpm restart ¶服务端注册 1234567891011121314151617181920class ApiController&#123; public function getUserInfo($uid) &#123; return json_encode([ &#x27;uid&#x27;=&gt;$uid, &#x27;username&#x27;=&gt;&#x27;lihongwei&#x27;, ]); &#125; public function getDealInfo($dealid) &#123; return json_encode([ &#x27;did&#x27;=&gt;$dealid, &#x27;dealname&#x27;=&gt;&#x27;haihang&#x27;, ]); &#125;&#125;$service = new \\Yar_Server(new ApiController());$service-&gt;handle(); ¶客户端调用 1234567891011121314151617181920212223242526 //同步 $client = new \\Yar_Client(&quot;http://yaf.dev&quot;); /* 以下是最佳setopt */ $client-&gt;SetOpt(YAR_OPT_CONNECT_TIMEOUT, 1000); /* 同步调用远程服务 */ $result = $client-&gt;getUserInfo(100); //异步 \\Yar_Concurrent_Client::call(&quot;http://yaf.dev&quot;, &quot;getUserInfo&quot;,[11320],[$this , &#x27;getUserInfoCallback&#x27;]);\\Yar_Concurrent_Client::call(&quot;http://yaf.dev&quot;, &quot;getDealInfo&quot;,[18800],[$this , &#x27;getDealInfoCallback&#x27;]);\\Yar_Concurrent_Client::call(&quot;http://yaf.dev&quot;, &quot;getDealInfo&quot;,[18800],[$this , &#x27;getDealInfoCallback&#x27;],[$this , &#x27;getDealInfoCallbackError&#x27;],[YAR_OPT_PACKAGER =&gt; &quot;json&quot;]);\\Yar_Concurrent_Client::call(&quot;http://yaf.dev&quot;, &quot;getDealInfo&quot;,[18800],[$this , &#x27;getDealInfoCallback&#x27;],[$this , &#x27;getDealInfoCallbackError&#x27;],[YAR_OPT_TIMEOUT=&gt;1]);\\Yar_Concurrent_Client::loop();public function getUserInfoCallback($retval, $callinfo) &#123; $data = json_decode($retval ,true); var_dump($data[&#x27;username&#x27;]);&#125;","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/categories/php/"}],"tags":[{"name":"yar","slug":"yar","permalink":"http://blog.nicexiangcun.com/tags/yar/"}]},{"title":"深入理解正则表达式","slug":"正则","date":"2017-02-25T11:58:37.000Z","updated":"2020-11-20T13:06:15.521Z","comments":true,"path":"2017/02/25/正则/","link":"","permalink":"http://blog.nicexiangcun.com/2017/02/25/%E6%AD%A3%E5%88%99/","excerpt":"¶表达式测试 🐝\n推荐一个测试地址 http://www.rexv.org/\n测试题：用单引号和双引号匹配 \\$\n答案 ： 首先\\$都是元字符都需要转义，转义结果为：\\\\\\$\n\n用单引号来标识的正则: /\\\\\\\\\\$/\n用双引号来标识的正则: /\\\\\\\\\\\\\\$/\n\n¶🌴 分组和后向引用\n通过次数限定符，来限定前面括号中的单元。匹配到的单元将会被捕获，捕获到的内容可以在正则表达式的后面通过\\1,\\2,\\3获取。\n¶贪婪与非贪婪 🪲\n\n.* 贪婪模式，贪婪模式会回溯匹配效率低。\n.*? 非贪婪模式\n","text":"¶表达式测试 🐝 推荐一个测试地址 http://www.rexv.org/ 测试题：用单引号和双引号匹配 \\$ 答案 ： 首先\\$都是元字符都需要转义，转义结果为：\\\\\\$ 用单引号来标识的正则: /\\\\\\\\\\$/ 用双引号来标识的正则: /\\\\\\\\\\\\\\$/ ¶🌴 分组和后向引用 通过次数限定符，来限定前面括号中的单元。匹配到的单元将会被捕获，捕获到的内容可以在正则表达式的后面通过\\1,\\2,\\3获取。 ¶贪婪与非贪婪 🪲 .* 贪婪模式，贪婪模式会回溯匹配效率低。 .*? 非贪婪模式 ¶正则表达式的回溯 12/&quot;.*&quot;/ 和 /&quot;.*?&quot;/分别匹配 &#x27;my name is &quot;lhw&quot; who &quot;are&quot; you &#x27; &quot;.*&quot;匹配过程：当匹配到第一个&quot;字符的时候由于.是匹配非换行符的所有字符，所以就从&quot;一直匹配的最后，匹配到最后然后在逐次往前回溯，拿每个字符和最后一个&quot;符号匹配，直到匹配到为止，所以&quot;.*&quot;匹配的结果是 “lhw” who “are” &quot;.*?&quot;匹配过程：当匹配到第一个&quot;字符的时候，就会逐次的从当前的&quot;后面的字符和最后&quot;做匹配。直到匹配为止。 ¶✂️ 限定符和元字符使用时注意 所有限定符都是限定它前面的一个子单元出现的次数。 只有元字符出现在它该出现的地方才能起到元字符作用，否则就是普通字符如： [-0-9A-Z.?]由于[]优先级高于.?所以这里的.?就是普通字符 ¶PCRE 主要函数 preg_grep 返回匹配模式的数组条目 preg_match 执行一个正则表达式匹配 preg_match_all 执行一个全局正则表达式匹配 preg_filter 执行一个正则表达式搜索和替换 preg_replace 执行一个正则表达式搜索和替换 preg_replace_callback 执行一个正则表达式搜索且使用一个回调进行替换 preg_split 通过一个正则表达式分割字符串 ¶正则表达式 - 元字符 🐽 字符 描述 \\ 有三种含义，1是转义如 \\\\,\\(,2是特殊字符如\\n 匹配一个换行符,3是向后引用 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multilin性，$也匹配“\\n”或“\\r”之前的位置 | 匹配前面的子表达式零次或多次(注意：前面的子表达)。例如，lhw* 能匹配 “lh&quot;和&quot;lhw” 以及 “lhwww”。等价于{0,} | 匹配前面的子表达式一次或多次。例如，‘lhw+’ 能匹配 “lhw” 以及 “lhwww”，但不能匹配 “lh”。+ 等价于 {1,} ? | 匹配前面的子表达式零次或一次。例如，“lhw(nb)?” 可以匹配 “lhw” 或 “lhwnb” 等价于 {0,1} {n} | 匹配确定的 n 次。例如，‘lhw{2}’ 不能匹配 “lhw” 但是能匹配 “lhww” {n,} | 至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foood” 中的所有 o,‘o{1,}’ 等价于 ‘o+’,‘o{0,}’ 则等价于 ‘o*’ {n,m} | 最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’ . | 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像&quot;(.|\\n)&quot;的模式 ? | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，‘o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’ x|y | 匹配 x 或 y。例如，‘z|food’ 能匹配 “z” 或 “food”。‘(z|f)ood’ 则匹配 “zood” 或 “food” [xyz] | 匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’ [^xyz] | 匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、‘l’、‘i’、‘n’ [a-z] | 匹配指定范围内的任意字符。例如，‘[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符 [^a-z] | 匹配任何不在指定范围内的任意字符。例如，‘[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符 \\d | 匹配一个数字字符。等价于 [0-9] \\D | 匹配一个非数字字符。等价于 [^0-9] \\n | 匹配一个换行符 \\s | 匹配任何空白字符，包括空格、制表符、换页符等等 \\S |匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v] \\r | 匹配一个回车符 \\t | 匹配一个制表符 \\w | 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’ \\W | 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’ \\xn | 十六进制转义值必须为确定的两个数字长。例如，‘\\x41’ 匹配 “A”。‘\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码 \\nm | 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm [\\u4e00-\\u9fa5] | unicode码范围，匹配任意汉字，\\u固定写法，4e00为16进制的unicode编码","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/categories/php/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.nicexiangcun.com/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"字符串和字符编码原理","slug":"字符串","date":"2017-02-24T12:56:53.000Z","updated":"2020-11-20T13:06:15.521Z","comments":true,"path":"2017/02/24/字符串/","link":"","permalink":"http://blog.nicexiangcun.com/2017/02/24/%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"¶🕷️单引号和双引号的区别\n单引号和双引号的区别经常被当做面试题被问到，但是大部分回答的并不好，其中有以下几种区别经常被忽略。\n当字符串用双引号或者heredoc结构定义时，其中变量可以被解析，同时可以解析以下字符\n\n\\n,\\r,\\t,\\v,\\e,\\f,\\,$,&quot;\n[0-7]{1,3}符合该正则表达式的，是以一个八进制方式来表达的字符，例如\n\n12345/*** 101转10进制：1*8^2+0*8^1+1*8^0 = 64+0+1 = 65* 102转10进制：1*8^2+0*8^1+2*8^0 = 64+0+2 = 66*/echo &quot;\\101\\102&quot; // AB\n\n\\x[0-9A-Fa-f]{1,2}符合该正则表达的，是以一个十六进制方式来表达的字符，例如\n\n12345/*** 41转10进制：4*16^1+1*16^0 = 64+1 = 65* 42转10进制：4*16^2+2*16^0 = 64+2 = 66*/echo &quot;\\x41\\x42&quot; // AB\n\n单引号只转义\\ 和 ’\n\n¶↘️ 关于字符串下标\n\n获取字符串中的字符，可以通过下标去获取。\n用超出字符串长度的下标写入字符串，会拉长该字符串，中间以空格填充。\n\n123$str = &#x27;lhw&#x27;;$str[10] = &#x27;ok&#x27;;echo $str;\n¶🐜 字符串串行化\n串行化的目的：将不易于存储的数据结构，通过串行化来存储数据库或者文件当中。\n\nserialize()   性能稍差，可序列号对象\njson_encode() 性能好，这序列化数组，并且不同语言可通用\nvar_export($arr,true) 序列化数组，并写入文件，可做文件缓存使用，或者写入日志调试\n\n\nvar_export 利用它的特性，可以将读取数据库的配置等信息，写入缓存文件。\n","text":"¶🕷️单引号和双引号的区别 单引号和双引号的区别经常被当做面试题被问到，但是大部分回答的并不好，其中有以下几种区别经常被忽略。 当字符串用双引号或者heredoc结构定义时，其中变量可以被解析，同时可以解析以下字符 \\n,\\r,\\t,\\v,\\e,\\f,\\,$,&quot; [0-7]{1,3}符合该正则表达式的，是以一个八进制方式来表达的字符，例如 12345/*** 101转10进制：1*8^2+0*8^1+1*8^0 = 64+0+1 = 65* 102转10进制：1*8^2+0*8^1+2*8^0 = 64+0+2 = 66*/echo &quot;\\101\\102&quot; // AB \\x[0-9A-Fa-f]{1,2}符合该正则表达的，是以一个十六进制方式来表达的字符，例如 12345/*** 41转10进制：4*16^1+1*16^0 = 64+1 = 65* 42转10进制：4*16^2+2*16^0 = 64+2 = 66*/echo &quot;\\x41\\x42&quot; // AB 单引号只转义\\ 和 ’ ¶↘️ 关于字符串下标 获取字符串中的字符，可以通过下标去获取。 用超出字符串长度的下标写入字符串，会拉长该字符串，中间以空格填充。 123$str = &#x27;lhw&#x27;;$str[10] = &#x27;ok&#x27;;echo $str; ¶🐜 字符串串行化 串行化的目的：将不易于存储的数据结构，通过串行化来存储数据库或者文件当中。 serialize() 性能稍差，可序列号对象 json_encode() 性能好，这序列化数组，并且不同语言可通用 var_export($arr,true) 序列化数组，并写入文件，可做文件缓存使用，或者写入日志调试 var_export 利用它的特性，可以将读取数据库的配置等信息，写入缓存文件。 ¶字符 相关关键字 位(bit b)，计算机最小存储单位，0或1组成 字节(byte B),计量单位 字符(char),可见字母，数字，符号等 ¶字符集和字符编码 字符集 所有抽象字符的集合，如 ASCII 字符集，Unicode 字符集 字符编码 一种约定规范，使字符和计算机直接建立对应关系，就是以二进制的数字对应字符集的字符。 ¶ASCII 编码 美国定义的字符集，只用一个字节标识的字符，使用字节的低7位标识一共2的7次方128个字符，这些字符都和二进制数字有了对应关系。 ¶Latin1 编码 (ISO-8859-1) 在ASCII编码基础上的扩展，主要是西欧国家的，范围是125-255(具体字符去 google) ¶GB2132编码 和 GBK编码 (中国) GB2132 只收了常用的6763个汉字 GBK在GB2132的基础上扩展了许多行的汉字 GB2132一个汉字用2个字节表示，一个字节占8位总共分为2的8次方(256)种可能，两个字节就是256*256=65536种不同的符合，但是中国只才用了两个字节的低7位128*128=16384种不同的汉字。但是在GB2132中为了和ASCII保持兼容，GB2132的每个字节中不能在用ASCII中的字符编码，所有实际GB2132所能表示的只有94*94=8836个。 ¶BIG5编码 (台湾) ¶ISO组织的Unicode字符集 Unicode的编码方式：UTF-8/UTF-16/UTF-32 Unicode 采用4个字节来表达一个字符 ¶UTF-8的编码规则 Unicode编码(16进制) UTF-8字节流(二进制) 0000-007F 0xxxxxxx 0080-07FF 110xxxxx 10xxxxxx 0800-FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000-10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 中国的汉字范围是4E00-9FFF,根据上面的规则可以看出，是0800-FFFF区间，所以UTF-8的汉字是3个字节。 如何把’北京’的unicode码 ‘21271’,'20140’转为UTF-8. 算出每个字的二进制 从右至左一次填充，不足补0： 1110xxxx 10xxxxxx 10xxxxxx 在将二进制转为16进制 将16进制编辑到编辑器，已UTF-8查看 ¶UTF-16的编码规则 和 UTF-8类似，采用两个字节存储一个字符，但是不兼容ASCII码，如果存储英文势必会造成空间的浪费 ¶GBK和UTF-8如何选择 优先选择UTF-8 为了节省存储空间选择GBK 支持多种语言选择UTF-8 PHP 中的json_encode()是只支持UTF-8的汉字。","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/categories/php/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://blog.nicexiangcun.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"微服务","slug":"微服务","date":"2017-02-18T12:40:02.000Z","updated":"2020-11-20T13:06:15.521Z","comments":true,"path":"2017/02/18/微服务/","link":"","permalink":"http://blog.nicexiangcun.com/2017/02/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","excerpt":"¶微服务目的\n一直在说微服务，微服务到底能带来什么好处呢，从老板的角度来说，他们真正只在乎两件事情：\n系统要稳定，别挂\n出活要快，我让你们加什么功能，赶紧就给加上\n稳定性和交付速度就是最重要的两个指标了。\n¶微服务切分\n把一个单体应用切分为多个进程，独立部署是必然的。独立发布，独立测试，独立流水线，无论怎么拆分，都会比合在一起要好。但是也会设计到跨进程的事务一致性问题如何保证，以及跨网络延时等用户体验问题。","text":"¶微服务目的 一直在说微服务，微服务到底能带来什么好处呢，从老板的角度来说，他们真正只在乎两件事情： 系统要稳定，别挂 出活要快，我让你们加什么功能，赶紧就给加上 稳定性和交付速度就是最重要的两个指标了。 ¶微服务切分 把一个单体应用切分为多个进程，独立部署是必然的。独立发布，独立测试，独立流水线，无论怎么拆分，都会比合在一起要好。但是也会设计到跨进程的事务一致性问题如何保证，以及跨网络延时等用户体验问题。 ¶微服务之间调用和异步化 SOAP和RPC都是SOA的具体实现方式。这里要说的是由于服务的拆分，消息总线或者消息队列也是重要的一个设计环节，因为RPC 和消息队列最本质的区别，不是网络开销，不是提高并发，而是职责的反转。比如我们开发中经常遇到这样的业务流程，卡券团队对订单团队说你们下单的时候要调一下我的接口我要送卡券…,可以转变成不是我调你而是你主动来取。我只要将事件handle放进消息队列就ok啦。当然RPC好还是走消息队列好，还是要根据业务去做权衡。","raw":null,"content":null,"categories":[{"name":"devops","slug":"devops","permalink":"http://blog.nicexiangcun.com/categories/devops/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://blog.nicexiangcun.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"devops","slug":"devops","date":"2016-12-04T02:49:07.000Z","updated":"2020-11-20T13:06:15.511Z","comments":true,"path":"2016/12/04/devops/","link":"","permalink":"http://blog.nicexiangcun.com/2016/12/04/devops/","excerpt":"\ndevops\n\n\n虽然不喜欢devops，但是还是要总结一下在devops中遇到一些所使用的工具。\nhttps://github.com/integrations\n\n\n¶git\nhttp://blog.ffanfood.com/2016/07/09/git\n\n¶代码托管和代码审查\ngitlab / github ／ Code Review\n\n¶CI 自动化构件，测试，部署\nCircleCI ／ Travis CI\n\n¶日志聚集\nSlack  https://slack.com/\n\n¶项目与事务跟踪\nJIRA https://github.com/integrations/jira-software\n\n¶前端后端解藕（契约测试）","text":"devops 虽然不喜欢devops，但是还是要总结一下在devops中遇到一些所使用的工具。 https://github.com/integrations ¶git http://blog.ffanfood.com/2016/07/09/git ¶代码托管和代码审查 gitlab / github ／ Code Review ¶CI 自动化构件，测试，部署 CircleCI ／ Travis CI ¶日志聚集 Slack https://slack.com/ ¶项目与事务跟踪 JIRA https://github.com/integrations/jira-software ¶前端后端解藕（契约测试） http://www.infoq.com/cn/articles/power-of-raml 工具与安装： 1. 需要Node环境，下载nodejs：https://nodejs.org/en/ ，选择LTS版本 2. RAML API设计器：npm install -g api-designer 网页版ide 3. 对于前端（服务调用者）：npm install -g osprey-mock-service 4. 对于后端（服务提供者）：npm install -g abao 5. ide工具: Atom https://atom.io/，然后按照扩展api-workbench，类似phpstorm 6. PostMan 需要安装cookie扩展 相关命令： api-designer 网页版ide: 1. 命令行输入api-designer启动，浏览器自动打开http://localhost:3000/ osprey-mock-service 前端： 1. 命令行输入 osprey-mock-service --cors -f wallet-list.raml -p 6060 2. 返回：Mock service running at http://localhost:6060 成功状态 3. PostMan中输入地址调试，Header需添加Content-Type：application/x-www-form-urlencoded 4. --cors 解决js跨域问题 abao 后端： 1. 命令行输入abao raml-specs/wallet-list.raml -t 15000 -f login.js --server http://www.abc.com 2. --server 就是baseUri， -t 是响应时间， 文档与规范： RAML 规范官网： raml.org RAML 详细规范： fhttps://github.com/raml-org/raml-spec/blob/master/versions/raml-08/raml-08.md RAML 示例： http://static-anypoint-mulesoft-com.s3.amazonaws.com/API_examples_notebooks/raml-design3.html API 返回值规范： http://json-schema.org/ 作用： 1. 文档与规范 2. 自动化测试 3. Mock服务模拟 工程目录参考 https://github.com/raml-apis","raw":null,"content":null,"categories":[{"name":"devops","slug":"devops","permalink":"http://blog.nicexiangcun.com/categories/devops/"}],"tags":[{"name":"devops","slug":"devops","permalink":"http://blog.nicexiangcun.com/tags/devops/"}]},{"title":"php-trait","slug":"php-trait","date":"2016-11-30T13:42:12.000Z","updated":"2020-11-20T13:06:15.515Z","comments":true,"path":"2016/11/30/php-trait/","link":"","permalink":"http://blog.nicexiangcun.com/2016/11/30/php-trait/","excerpt":"","text":"¶单例模式 如果class new 起来嫌麻烦，👙 或者想使用单例模式，请在你的class中 use Singleton 12345678910111213141516171819202122232425trait Singleton&#123; protected static $__instances__ = array(); protected function __construct() &#123; &#125; public function __clone() &#123; throw new \\Exception(&#x27;Cloning &#x27;.__CLASS__.&#x27; is not allowed&#x27;); &#125; public static function getInstance() &#123; $class = get_called_class(); if (!isset(static::$__instances__[$class])) &#123; static::$__instances__[$class] = new static(); &#125; return static::$__instances__[$class]; &#125; public static function resetInstance() &#123; $class = get_called_class(); unset(static::$__instances__[$class]); &#125;&#125; 12345678910111213class Order extends \\AbstractOrder&#123; use Singleton public function getOrderInfo()&#123; //todo &#125;&#125;Order::getInstance()-&gt;getOrderInfo(); ¶laravel 多太关联结合trait","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/categories/php/"}],"tags":[{"name":"trait","slug":"trait","permalink":"http://blog.nicexiangcun.com/tags/trait/"}]},{"title":"非常coll的框架 vue-js","slug":"vue-js","date":"2016-11-22T13:49:03.000Z","updated":"2020-11-20T13:06:15.519Z","comments":true,"path":"2016/11/22/vue-js/","link":"","permalink":"http://blog.nicexiangcun.com/2016/11/22/vue-js/","excerpt":"¶数据双向绑定\nv-model 使用于 input ,textarea 将属性和我们的 data对象中的属性绑定在一起\n12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;vue-js&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;            &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;            &lt;pre&gt;                &#123;&#123; $data | json &#125;&#125;            &lt;/pre&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script&gt;        new Vue(&#123;            el:&#x27;#app&#x27;,            data:&#123;                message:&#x27;hello world !!&#x27;            &#125;        &#125;)    &lt;/script&gt;&lt;/html&gt;","text":"¶数据双向绑定 v-model 使用于 input ,textarea 将属性和我们的 data对象中的属性绑定在一起 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;vue-js&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;pre&gt; &#123;&#123; $data | json &#125;&#125; &lt;/pre&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; message:&#x27;hello world !!&#x27; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; ¶v-show 和 v-if 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue-js&lt;/title&gt; &lt;style&gt; #main&#123;border: 1px;width:800px;margin:100px auto;&#125; .name&#123;width:600px;height: 40px&#125; .passwd&#123;width:600px;height: 50px&#125; .name label&#123;display:inline-block;width: 60px&#125; .passwd label&#123;display:inline-block;width: 60px&#125; .error&#123;color:red&#125; &lt;/style&gt;&lt;/head&gt;&lt;!--v-show 和 v-if 的使用--&gt;&lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;app&quot;&gt; &lt;form action=&quot;&quot;&gt; &lt;div class=&quot;name&quot;&gt; &lt;label&gt;用户名:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot; v-model=&quot;username&quot;&gt; &lt;span class=&quot;error&quot; v-show=&quot;!username&quot;&gt;请输入用户名&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;passwd&quot;&gt; &lt;label&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; value=&quot;&quot; v-model=&quot;password&quot;&gt; &lt;span class=&quot;error&quot; v-show=&quot;!password&quot;&gt;请输入密码&lt;/span&gt; &lt;/div&gt; &lt;button v-show=&quot;username &amp;&amp; password&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; username : &#x27;&#x27;, password : &#x27;&#x27; &#125; &#125;)&lt;/script&gt;&lt;/html&gt;","raw":null,"content":null,"categories":[{"name":"vue","slug":"vue","permalink":"http://blog.nicexiangcun.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.nicexiangcun.com/tags/vue/"}]},{"title":"mac 开发大杂烩","slug":"mac","date":"2016-11-21T12:42:26.000Z","updated":"2020-11-20T13:06:15.514Z","comments":true,"path":"2016/11/21/mac/","link":"","permalink":"http://blog.nicexiangcun.com/2016/11/21/mac/","excerpt":"\n👀 mac终端常用配置\n¶安装oh my zsh\n首先安装 iterm2  http://www.iterm2.com\n然后进入 http://ohmyz.sh 根据以下文档安装 zshrc\n123git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n配置\nzsh 的配置主要集中在用户当前目录的.zshrc里，用 vim 或你喜欢的其他编辑器打开.zshrc：\n123456789101112131415161718alias cls=&#x27;clear&#x27;alias ll=&#x27;ls -l&#x27;alias la=&#x27;ls -a&#x27;alias vi=&#x27;vim&#x27;alias javac=&quot;javac -J-Dfile.encoding=utf8&quot;alias grep=&quot;grep --color=auto&quot;alias -s html=mate   # 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开alias -s rb=mate     # 在命令行直接输入 ruby 文件，会在 TextMate 中打开alias -s py=vi       # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似alias -s js=vialias -s c=vialias -s java=vialias -s txt=vialias -s gz=&#x27;tar -xzvf&#x27;alias -s tgz=&#x27;tar -xzvf&#x27;alias -s zip=&#x27;unzip&#x27;alias -s bz2=&#x27;tar -xjvf&#x27;","text":"👀 mac终端常用配置 ¶安装oh my zsh 首先安装 iterm2 http://www.iterm2.com 然后进入 http://ohmyz.sh 根据以下文档安装 zshrc 123git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 配置 zsh 的配置主要集中在用户当前目录的.zshrc里，用 vim 或你喜欢的其他编辑器打开.zshrc： 123456789101112131415161718alias cls=&#x27;clear&#x27;alias ll=&#x27;ls -l&#x27;alias la=&#x27;ls -a&#x27;alias vi=&#x27;vim&#x27;alias javac=&quot;javac -J-Dfile.encoding=utf8&quot;alias grep=&quot;grep --color=auto&quot;alias -s html=mate # 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开alias -s rb=mate # 在命令行直接输入 ruby 文件，会在 TextMate 中打开alias -s py=vi # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似alias -s js=vialias -s c=vialias -s java=vialias -s txt=vialias -s gz=&#x27;tar -xzvf&#x27;alias -s tgz=&#x27;tar -xzvf&#x27;alias -s zip=&#x27;unzip&#x27;alias -s bz2=&#x27;tar -xjvf&#x27; 安装完成，终端输入zsh进入 zsh ¶安装 zsh-autosuggestions 1git clone git://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions 在 .zshrc 添加： 1source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh 最后 source ~/.zshrc 更多 oh my zsh 配置参考： https://zhuanlan.zhihu.com/p/19556676 ¶iterm2 的配置 zsh的主题 ： sudo vi ~/.zshrc 下的 ZSH_THEME=“cloud” iterm2的主题： https://github.com/mbadolato/iTerm2-Color-Schemes https://draculatheme.com , Dracula.itermcolors (非常不错哦) 步骤：clone 选好的配色，command + , 呼出配置项 新建 profiles ,选择 Colors 选项导入配色文件,导入成功后，还要在 iTerm2 - Preferences - Profiles - Colors 里面右下方的 Color Presets 里面有没有刚刚导入的主题如图。 然后 command + o 可以选择配色实用了 经常使用的快捷键 command + o 选择主题配色 command ＋ 左右箭头 来回切换 command + enter 切换全屏 command + ; 查看历史命令 command + shift + h 查看剪贴板历史 ctrl + u 清除当前行(废除当前命令) ctrl + r 搜索命令历史 ctrl + d 删除当前光标的字符 ctrl + h 删除光标之前的字符 ctrl + w 删除光标之前的单词 ctrl + k 删除到文本末尾 ctrl + t 交换光标处文本 command + r 清屏1 ctrl + l 清屏2","raw":null,"content":null,"categories":[{"name":"mac","slug":"mac","permalink":"http://blog.nicexiangcun.com/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://blog.nicexiangcun.com/tags/mac/"}]},{"title":"laravel-设计模式","slug":"laravel-设计模式","date":"2016-11-18T15:03:31.000Z","updated":"2020-11-20T13:06:15.513Z","comments":true,"path":"2016/11/18/laravel-设计模式/","link":"","permalink":"http://blog.nicexiangcun.com/2016/11/18/laravel-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"\n¶容器注入\n关键词： 依赖倒置,依赖注入\n相当于Yii中的DI容器，使用目的，由于在我们平时写代码过程中使用new这个关键字被视为一种不好的习惯，所以laravel中提供了两种类型（多种方法）来帮我们自动实例化类。\n第一种方式：PHP 反射机制\nlaravel 会在实例化一个类触发了构造方法的时候检查构造方法所需要的依赖，并且自动实例化。不是全局的，根据业务场景去设计。\n第二种方式：全局的 App:bind() 和 serviceProvider 方法 如：\n1234567891011class Foo&#123;&#125;App::bind(&#x27;foo&#x27;,function()&#123;\treturn new Foo();&#125;)app()-&gt;make(&#x27;foo&#x27;)-&gt;method();\nlaravel中是用serviceProvider中的register方法 来帮顶我们需要的依赖单元 如\n12345678protected function register()&#123;\t$this-&gt;app-&gt;singleton(&#x27;file&#x27;,function()&#123;\t\treturn new Files;\t&#125;);&#125;","text":"¶容器注入 关键词： 依赖倒置,依赖注入 相当于Yii中的DI容器，使用目的，由于在我们平时写代码过程中使用new这个关键字被视为一种不好的习惯，所以laravel中提供了两种类型（多种方法）来帮我们自动实例化类。 第一种方式：PHP 反射机制 laravel 会在实例化一个类触发了构造方法的时候检查构造方法所需要的依赖，并且自动实例化。不是全局的，根据业务场景去设计。 第二种方式：全局的 App:bind() 和 serviceProvider 方法 如： 1234567891011class Foo&#123;&#125;App::bind(&#x27;foo&#x27;,function()&#123; return new Foo();&#125;)app()-&gt;make(&#x27;foo&#x27;)-&gt;method(); laravel中是用serviceProvider中的register方法 来帮顶我们需要的依赖单元 如 12345678protected function register()&#123; $this-&gt;app-&gt;singleton(&#x27;file&#x27;,function()&#123; return new Files; &#125;);&#125; 而所有的 serviceProvider 都会中laravel 的app.config 下配置，这样就可以通过多种方式来直接使用这个类类(php artisan make:privace 注册的服务)。 12345678910111213//app() 此方法在入口文件 index.php 中app()-&gt;make(&#x27;file&#x27;)-&gt;method();app()[&#x27;file&#x27;]-&gt;method();app(&#x27;file&#x27;)-&gt;method();//通过门面方式访问file::method(); 使用 serviceProvider的好处，如果这个类依赖过多的依赖单元可以种register的时候一次处理好，不用业务层每次重新构造。 ¶门面 Facade laravel 中提供了一个facade服务层来共应用成可以使用静态方法一样访问类中的成员方法 12345678910111213public static function __callStatic($method, $args)&#123; /* * 这个方法并不是laravel中 facade 中的，演示而已，new static()通常会替换成子类中构造注入或者方法注入的一个依赖，所以 * 这里有个问题一直是个疑惑，new static() ，在这里会注入依赖显然不合理，不知道，jwt第三方是怎么做的 */ $method = &#x27;dep&#x27;.ucfirst($method); if (method_exists(new static(), $method)) &#123; return call_user_func_array([new static(), $method], $args); &#125; throw new \\BadMethodCallException(&quot;Method [$method] does not exist.&quot;);&#125;","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"red-packet","slug":"red-packet","date":"2016-11-16T14:12:34.000Z","updated":"2020-11-20T13:06:15.517Z","comments":true,"path":"2016/11/16/red-packet/","link":"","permalink":"http://blog.nicexiangcun.com/2016/11/16/red-packet/","excerpt":"","text":"cmd的一个使用技巧 sudo !! , root的身份执行上次命令","raw":null,"content":null,"categories":[],"tags":[]},{"title":"phpstorm vagrant xdebug","slug":"xdebug","date":"2016-11-13T12:57:35.000Z","updated":"2020-11-20T13:06:15.519Z","comments":true,"path":"2016/11/13/xdebug/","link":"","permalink":"http://blog.nicexiangcun.com/2016/11/13/xdebug/","excerpt":"phpstorm 结合homestead 配置xdebug 👠\n¶编辑php配置文件\nhomestead ssh\nsudo vi /etc/php/7.0/fpm/conf.d/20-xdebug.ini\n添加 ：\n123456789zend_extension=/usr/lib/php/20151012/xdebug.soxdebug.remote_enable = 1xdebug.remote_connect_back = 1xdebug.remote_port = 9000xdebug.scream=0xdebug.cli_color=1xdebug.show_local_vars=1\n重启fpm\nsudo service php7.0-fpm restart","text":"phpstorm 结合homestead 配置xdebug 👠 ¶编辑php配置文件 homestead ssh sudo vi /etc/php/7.0/fpm/conf.d/20-xdebug.ini 添加 ： 123456789zend_extension=/usr/lib/php/20151012/xdebug.soxdebug.remote_enable = 1xdebug.remote_connect_back = 1xdebug.remote_port = 9000xdebug.scream=0xdebug.cli_color=1xdebug.show_local_vars=1 重启fpm sudo service php7.0-fpm restart ¶下载chrom xdebug-help 扩展 https://chrome.google.com/webstore/detail/eadndfjplgieldjbigjakmdgkmoaaaoc 配置xdebug-help： IDE key ： phpstorm ¶phpstorm 配置 呼出配置项，搜索php，选择一个版本。 配置ssh链接vagrant ,如果使用私钥链接位置在 .homestead\\.vagrant\\machines\\default\\virtualbox 如果有问题可以查看 phpinfo xdebug是否安装成功 ¶调试 打开 phpstorm xdebug 监听。 打开 xdebug-helper 扩展。 输入app.dev，phpstorm会弹出对话框，选择“Accept”。 然后选择 Preferences —&gt; Languages &amp; Frameworks — &gt; PHP —&gt; Servers 这时我们需要修改项目外层路径对应的映射关系，否则就只能对index.php进行debug，而其他文件的断点将不会起作用 监听多个域名，要做server 下配置，并且初次访问，必须访问index.php","raw":null,"content":null,"categories":[{"name":"bug","slug":"bug","permalink":"http://blog.nicexiangcun.com/categories/bug/"}],"tags":[{"name":"xdebug","slug":"xdebug","permalink":"http://blog.nicexiangcun.com/tags/xdebug/"}]},{"title":"php7","slug":"php7","date":"2016-11-07T14:13:18.000Z","updated":"2020-11-20T13:06:15.515Z","comments":true,"path":"2016/11/07/php7/","link":"","permalink":"http://blog.nicexiangcun.com/2016/11/07/php7/","excerpt":"¶php7\n排序\n1234567891011121314$games = [&#x27;Mass Effect&#x27;,&#x27;Super&#x27;,&#x27;Zelda&#x27;,&#x27;Fallout&#x27;,&#x27;Metal Grear&#x27;];usort($games,function($a,$b))&#123;\t//return $a &lt;=&gt; $b; // if a&lt;b return -1 , a=b return 0 ,a&gt;b return 1\t  return $b &lt;=&gt; #a; \t//return $a - $b ;&#125;var_dump($games);//$games 适合于对象\n三元声明更简单\n12345678$name = &#x27;lhw&#x27;;echo $name ?? &quot;cxx&quot;;  //等价于 empty($name) ? $name : &#x27;cxx&#x27; echo $_GET[&#x27;name&#x27;] ?? &#x27;cxx&#x27;; //等于 isset($_GET[&#x27;name&#x27;]) ? $_GET[&#x27;name&#x27;] : &#x27;cxx&#x27;;","text":"¶php7 排序 1234567891011121314$games = [&#x27;Mass Effect&#x27;,&#x27;Super&#x27;,&#x27;Zelda&#x27;,&#x27;Fallout&#x27;,&#x27;Metal Grear&#x27;];usort($games,function($a,$b))&#123; //return $a &lt;=&gt; $b; // if a&lt;b return -1 , a=b return 0 ,a&gt;b return 1 return $b &lt;=&gt; #a; //return $a - $b ;&#125;var_dump($games);//$games 适合于对象 三元声明更简单 12345678$name = &#x27;lhw&#x27;;echo $name ?? &quot;cxx&quot;; //等价于 empty($name) ? $name : &#x27;cxx&#x27; echo $_GET[&#x27;name&#x27;] ?? &#x27;cxx&#x27;; //等于 isset($_GET[&#x27;name&#x27;]) ? $_GET[&#x27;name&#x27;] : &#x27;cxx&#x27;; 返回类型声明 123456789101112131415class User&#123;&#125;interface SomeInterface&#123; public function getUser() : User;&#125;class SomeClass implements SomeInterface &#123; public function getUser() : User &#123; return new User; &#125;&#125;(new SomeClass)-&gt;getUser 12345678910class User&#123;&#125;function getUser($id) : User &#123; if (userDoesNotExists($id)) return false; return User::find($id);&#125;var_dump(getUser()); psr4 加载规范 12345678910111213141516171819202122232425262728293031323334353637383940414243//touch composer.json&#123; &quot;autoload&quot; :&#123; &quot;psr-4&quot;:&#123; &quot;App\\\\&quot;:&quot;./&quot; &#125; &#125;&#125;//然后 composer install//去创建几个 class// Person.phpnamespace App;class Person&#123;&#125;//Animal.phpnamespace App;class Animal &#123;&#125;//如何来使用//touch index.phprequire &#x27;vendor/autoload.php&#x27;;use App\\Person;use App\\Animal;//同空间下，整合如下use App\\&#123; Person, Animal, Foo\\Bar\\Baz&#125; 匿名类的用法 1234567891011121314151617181920212223242526272829303132333435interface Logger &#123; public function log($message);&#125;class TerminalLogger implements Logger &#123; public function log($message)&#123; var_dump($message); &#125;&#125;class Application &#123; protected $logger; public function setLogger(Logger $logger)&#123; $this-&gt;logger = $logger; return $this; &#125; public function action()&#123; $this-&gt;logger-&gt;log(&#x27;Doing things.&#x27;); &#125;&#125;$app = new Application();$app-&gt;setLogger(new TerminalLogger);$app-&gt;action(); 使用匿名类 1234567891011121314151617181920212223242526272829303132333435363738interface Logger &#123; public function log($message);&#125;class Application &#123; protected $logger; public function setLogger(Logger $logger)&#123; $this-&gt;logger = $logger; return $this; &#125; public function action()&#123; $this-&gt;logger-&gt;log(&#x27;Doing things.&#x27;); &#125;&#125;$app = new Application();//使用匿名类在 业务逻辑层 依赖注入一个具体$app-&gt;setLogger(new class implements Logger&#123; public function log($message)&#123; var_dump($message); &#125;&#125;);$app-&gt;action(); laravel 中的例子 12345678910111213141516171819202122class BookTransformer &#123; public function transform()&#123; return []; &#125;&#125;class Item &#123; public function __construct($transformer)&#123; &#125;&#125;$item = new Item(new BookTransformer); 使用匿名类 1234567891011121314151617181920212223class Item &#123; public function __construct($transformer)&#123; &#125;&#125;$item = new Item(new class&#123; public function transform()&#123; return [] ; &#125;&#125;);","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/categories/php/"}],"tags":[{"name":"php7","slug":"php7","permalink":"http://blog.nicexiangcun.com/tags/php7/"}]},{"title":"Ubuntu 14 PHP 5.6 升级到PHP 7.0","slug":"up-php7","date":"2016-10-24T04:25:28.000Z","updated":"2020-11-20T13:06:15.519Z","comments":true,"path":"2016/10/24/up-php7/","link":"","permalink":"http://blog.nicexiangcun.com/2016/10/24/up-php7/","excerpt":"¶Ubuntu 14 PHP 5.6 升级到PHP 7.0\n备份之前的配置，备份之前的配置，备份之前的配置 ！！！\n适用于Ubuntu 14 版本的VPS，Ubuntu 16 版本貌似直接就包含了php7.0\n1.先解决有可能存在的语言问题\n执行\n12sudo apt-get update sudo apt-get install -y language-pack-en-base\n然后命令行配置：\n123locale-gen en_US.UTF-8export LANG=en_US.UTF-8export LC_ALL=en_US.UTF-8\n2.删除原来的php5.6\n1sudo apt-get purge php5-fpm &amp;&amp; apt-get --purge autoremove\n3.添加php7.0的仓库\n12sudo apt-get install software-properties-commonsudo add-apt-repository ppa:ondrej/php","text":"¶Ubuntu 14 PHP 5.6 升级到PHP 7.0 备份之前的配置，备份之前的配置，备份之前的配置 ！！！ 适用于Ubuntu 14 版本的VPS，Ubuntu 16 版本貌似直接就包含了php7.0 1.先解决有可能存在的语言问题 执行 12sudo apt-get update sudo apt-get install -y language-pack-en-base 然后命令行配置： 123locale-gen en_US.UTF-8export LANG=en_US.UTF-8export LC_ALL=en_US.UTF-8 2.删除原来的php5.6 1sudo apt-get purge php5-fpm &amp;&amp; apt-get --purge autoremove 3.添加php7.0的仓库 12sudo apt-get install software-properties-commonsudo add-apt-repository ppa:ondrej/php 4.安装php7.0 123456sudo apt-get update sudo apt-get install php7.0sudo apt-get install php7.0-mysqlsudo apt-get install php7.0-fpmsudo apt-get install php7.0-curl php7.0-xml php7.0-mcrypt php7.0-json php7.0-gd php7.0-mbstring 上面可以一步一步来安装，如果出现依赖冲突的情况，请一个一个安装。 5.配置新的php.ini 12sudo vim /etc/php/7.0/fpm/php.ini#将cgi.fix_pathinfo=1这一行去掉注释，将1改为0。 6.配置php-fpm 12sudo vim /etc/php/7.0/fpm/pool.d/www.conf# 配置这个 listen = /var/run/php7.0-fpm.sock 7.nginx 配置 1sudo vim /etc/nginx/sites-enabled/default 配置相对应的路径和 location,(以laravel项目为例)： 123456789101112131415161718192021222324listen 80 default_server;listen [::]:80 default_server ipv6only=on;root your_website_root;index index.php index.html index.htm;# Make site accessible from http://localhost/server_name your_domain;location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ /index.php?$query_string; # Uncomment to enable naxsi on this location # include /etc/nginx/naxsi.rules&#125;location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 注意这里的 fastcgi_pass unix:/var/run/php7.0-fpm.sock; 要和第6步的 php-fpm 配置：/var/run/php7.0-fpm.sock; 一致。 如果使用 https 的话，推荐： 1234567ssl on;ssl_certificate /etc/nginx/ssl/ssl.crt;ssl_certificate_key /etc/nginx/ssl/ssl.key;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;ssl_prefer_server_ciphers on; 开启 gzip 可参考，配置文件位于 nginx.conf： 1234567891011gzip on;gzip_disable &quot;msie6&quot;;gzip_vary on;gzip_proxied any;gzip_comp_level 5;gzip_min_length 256;gzip_buffers 16 8k;gzip_http_version 1.1;gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/categories/php/"}],"tags":[{"name":"php7","slug":"php7","permalink":"http://blog.nicexiangcun.com/tags/php7/"}]},{"title":"阿里云站点部署","slug":"laravel-webhook","date":"2016-10-13T03:53:34.000Z","updated":"2020-11-20T13:06:15.513Z","comments":true,"path":"2016/10/13/laravel-webhook/","link":"","permalink":"http://blog.nicexiangcun.com/2016/10/13/laravel-webhook/","excerpt":"以 Ubuntu 14.04 为例\n¶通过下面的命令来删除Apache\n123sudo service apache2 stopupdate-rc.d -f apache2 removesudo apt-get remove apache2\n删除完之后，更新一下包列表\n1sudo apt-get update\n¶安装Nginx\n12# 注意nginx安装需要第三方库的依赖，通常有 pcre库（支持rewrite模块）zlib库（支持gzip模块）和openssl库（支持ssl模块） sudo apt-get install nginx\n安装完Nginx，执行｀sudo service nginx start｀再在浏览器地址栏输入你的公网IP，你就可以看的welcome to Nginx的界面了\n¶安装PHP\n1sudo apt-get install php5-fpm php5-cli php5-mcrypt\n只有通过php5-fpm，PHP在Nginx下才能正常运行，遂，安装之。\n至于php5-mcrypt，有些PHP框架会依赖于这个，比如Laravel就是，所以也把它装上了。\n¶配置php\n1sudo vim /etc/php5/fpm/php.ini\n打开PHP配置文件，找到cgi.fix_pathinfo选项，去掉它前面的注释分号;，然后将它的值设置为0,如下 cgi.fix_pathinfo=0\n启用php5-mcrypt: sudo php5enmod mcrypt\n重启php5-fpm: sudo service php5-fpm restart","text":"以 Ubuntu 14.04 为例 ¶通过下面的命令来删除Apache 123sudo service apache2 stopupdate-rc.d -f apache2 removesudo apt-get remove apache2 删除完之后，更新一下包列表 1sudo apt-get update ¶安装Nginx 12# 注意nginx安装需要第三方库的依赖，通常有 pcre库（支持rewrite模块）zlib库（支持gzip模块）和openssl库（支持ssl模块） sudo apt-get install nginx 安装完Nginx，执行｀sudo service nginx start｀再在浏览器地址栏输入你的公网IP，你就可以看的welcome to Nginx的界面了 ¶安装PHP 1sudo apt-get install php5-fpm php5-cli php5-mcrypt 只有通过php5-fpm，PHP在Nginx下才能正常运行，遂，安装之。 至于php5-mcrypt，有些PHP框架会依赖于这个，比如Laravel就是，所以也把它装上了。 ¶配置php 1sudo vim /etc/php5/fpm/php.ini 打开PHP配置文件，找到cgi.fix_pathinfo选项，去掉它前面的注释分号;，然后将它的值设置为0,如下 cgi.fix_pathinfo=0 启用php5-mcrypt: sudo php5enmod mcrypt 重启php5-fpm: sudo service php5-fpm restart ¶在搭建完LEMP环境之后，首先要明确两个重要目录 Nginx的默认root文件夹 /usr/share/nginx/html Nginx的服务器配置文件所在目录 /etc/nginx/sites-available/ ¶部署Laravel 创建网站的根目录 sudo mkdir -p /var/www 配置nginx服务器 sudo vim /etc/nginx/sites-available/default 打开nginx的配置文件之后，找到server这一块，大概是长这个样子的 12345678910111213server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /usr/share/nginx/html; index index.html index.htm; server_name localhost; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 其中root，index ，server_name和location这几行需要稍微修改一下 1234567891011121314server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /var/www/laravel/public; index index.php index.html index.htm; server_name server_domain_or_IP; # 将server_domain_or_IP修改为你的公网IP location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125;&#125; 最后我们还需要配置一下Nginx，让其执行PHP文件。同样是在这个文件里，在location下方添加下面的配置： 12345678910111213141516171819202122server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /var/www/laravel/public; index index.php index.html index.htm; server_name server_domain_or_IP; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 配置完之后重启Nginx，使上面的配置项生效。 sudo service nginx restart ¶创建Laravel项目 第一种方式： 直接通过composer来安装,安装composer 12cd ~curl -sS https://getcomposer.org/installer | php 如果 curl 有关于ssl错误可以尝试一下方式： 12345wget https://getcomposer.org/installerand php installer; composer全局使用： sudo mv composer.phar /usr/local/bin/composer 或者 sudo mv composer.phar /usr/bin/composer 然后在/var/www目录下直接执行 sudo composer create-project laravel/laravel laravel 第二种方式： 使用Git和Coding平台 安装git sudo apt-get install git 安装完成就可以使用git了，然后在Coding上创建一个私有项目laravel，里面包含所有该Laravel项目所需代码。 一旦本地代码都推送到Coding，然后在/var/www目录下直接使用 git clone your-project-git-link your-project-git-link替换为你Coding上的laravel项目地址 注意： 不管哪种方式安装的代码，/var/www/都是属于root用户的，而访问网站的用户则需要正确的权限和访问限制，我们可以通过下面的命令来实现。 sudo chown -R :www-data /var/www/laravel 根据Laravel的官方文档，/var/www/laravel/storage目录需要给网站的用户写权限 sudo chmod -R 775 /var/www/laravel/storage 同时还要执行以下操作 123php artisan cache:clear //在bootstrap/cache 生成 services.php 文件php artisan key:generate //将生成的key复制到config/app.php替换82行的APP_KEY键值。 ¶ssh 登录服务器 ssh-keygen -t rsa 本地生成秘钥对 接下来需要将本地的 id_rsa.pub 拷贝服务器上。 ssh登录服务器创建 .ssh 目录 12cd ~sudo mkdir .ssh 切回到本地 .ssh 目录 scp id_rsa.pub root@123.98.35.77:~/.ssh/id_rsa.pub 输入服务器密码拷贝 拷贝成功回到服务器 cat id_rsa.pub &gt;&gt; authorized_keys 最后删掉 id_rsa.pub ,退出服务器，重新登录，就不用输入密码了。 ¶利用webhook 实现PHP 自动部署 git 代码 首先推荐两篇文章 http://m.aoh.cc/149.html http://overtrue.me/articles/2015/01/how-to-deploy-project-with-git-hook.html 登录服务器部署用户公钥 ssh-keygen -t rsa -C &quot;bjletaoba@sina.com&quot; 将用户公钥部署到codding 的用户设置中 创建目录 sudo mkdir /var/www/.ssh 修改所属主 (针对 nginx 的) sudo chown -R www-data:www-data /var/www/.ssh/ 部署项目公钥 (针对 nginx,注意 id_rsa 的权限必须不能上777 或者 755 ，可以上700) sudo -Hu www-data ssh-keygen -t rsa //注意所在的当前目录必须在 www下 部署到 codding 的项目中 sudo cat /var/www/.ssh/id_rsa.pub 准备部署代码和注册路由 路由要注册到 middleware 外面 123456Route::group([&#x27;middleware&#x27;=&gt;[&#x27;web&#x27;]],function()&#123;&#125;)Route::any(&#x27;/deploy&#x27;,&#x27;DeployController@deploy&#x27;); 123456789101112131415161718public function deploy(Request $request)&#123; $token = &#x27;ffanfood&#x27;; $target = &#x27;/var/www/ffanfood/aliyun&#x27;; // 生产环境web目录 $wwwUser = &#x27;www-data&#x27;; $wwwGroup = &#x27;www-data&#x27;; $json = json_decode(file_get_contents(&#x27;php://input&#x27;),true); if(empty($json[&#x27;token&#x27;]) || $json[&#x27;token&#x27;] !== $token)&#123; exit(&#x27;error_request&#x27;); &#125; file_put_contents(&#x27;deploy.log&#x27;,var_export($json,true),FILE_APPEND); $cmds = array( &quot;cd $target &amp;&amp; git pull&quot;, &quot;chown -R &#123;$wwwUser&#125;:&#123;$wwwGroup&#125; $target/&quot;, ); foreach ($cmds as $cmd) &#123; shell_exec($cmd); &#125;&#125; 以上代码可以使用 php-shell-wrapper 这个 包 https://github.com/adambrett/php-shell-wrapper 1234567891011/** * 执行cd 命令 * @param $paht * @return $this */ protected function cdInfo($paht)&#123; $command = new Command(&#x27;cd&#x27;); $command-&gt;addParam(new Param($paht)); $this-&gt;shell-&gt;run($command); return $this; &#125; 修改git配置和保存git用户名密码 (会在 ／var/www 下生成git 配置文件) 123sudo -Hu www git config --global credential.helper store # 永久保存sudo -Hu www-data git config --global user.name lhwsudo -Hu www-data git config --global user.email bjletaoba@sina.com 初始化 (注意要用ssh 的链接 这样就不用输入密码) sudo -Hu www-data git clone git@git.coding.net:goodawei/aliyun_laravel_5_2.git --depth=1","raw":null,"content":null,"categories":[{"name":"webserver","slug":"webserver","permalink":"http://blog.nicexiangcun.com/categories/webserver/"}],"tags":[{"name":"webhook","slug":"webhook","permalink":"http://blog.nicexiangcun.com/tags/webhook/"}]},{"title":"git","slug":"git","date":"2016-07-09T13:20:05.000Z","updated":"2020-11-20T13:06:15.512Z","comments":true,"path":"2016/07/09/git/","link":"","permalink":"http://blog.nicexiangcun.com/2016/07/09/git/","excerpt":"git 的配置项  git config 以下的三个级别\n¶global\n针对一台电脑中一个用户，配置文件通常中用户的加目录的 .gitconfig 中\n1234567891011git config --配置级别  选项.属性 值 如：git config --global color.ui true\t\t\t\t\t＃配置ui颜色git config --global user.name lhw                   ＃指定提交的用户名git config --global user.email bjletaoba@sina.com   ＃指定提交的用户邮箱git config --global core.editor emacs  (vim)        ＃指定打开的编辑器git config --global merge.tool vimdiff              ＃指定比较工具git config --list                                   ＃查看配置项git help config                                     ＃帮助\n¶system\n针对一台电脑，配置文件通常中/etc/.gitconfig 下\n¶local\n针对每一个项目，配置文件通常中 每个项目的 .git/文件夹下\n常用查看命令\ngit status\ngit log --oneline\ngit log --oneline --graph\ngit  show  hash值 查看状态和跟踪日志和hash\n¶git add 用法\ngit add 将文件放入缓存区，其目的是为下次的 commit 做准备，其实每次 git commit 提交的文件都是 缓存区的，如果在缓存区的文件commit之前在次修改，那么修改的部分不会commit到版本控制中\n12345git add . \t\t#添加所有文件git add *.php \t# 添加PHP文件git add /dir/* \t#添加目录","text":"git 的配置项 git config 以下的三个级别 ¶global 针对一台电脑中一个用户，配置文件通常中用户的加目录的 .gitconfig 中 1234567891011git config --配置级别 选项.属性 值 如：git config --global color.ui true ＃配置ui颜色git config --global user.name lhw ＃指定提交的用户名git config --global user.email bjletaoba@sina.com ＃指定提交的用户邮箱git config --global core.editor emacs (vim) ＃指定打开的编辑器git config --global merge.tool vimdiff ＃指定比较工具git config --list ＃查看配置项git help config ＃帮助 ¶system 针对一台电脑，配置文件通常中/etc/.gitconfig 下 ¶local 针对每一个项目，配置文件通常中 每个项目的 .git/文件夹下 常用查看命令 git status git log --oneline git log --oneline --graph git show hash值 查看状态和跟踪日志和hash ¶git add 用法 git add 将文件放入缓存区，其目的是为下次的 commit 做准备，其实每次 git commit 提交的文件都是 缓存区的，如果在缓存区的文件commit之前在次修改，那么修改的部分不会commit到版本控制中 12345git add . #添加所有文件git add *.php # 添加PHP文件git add /dir/* #添加目录 git 使用总结 ¶如何使commit尽可能的少 场景：通常一个commit就代表一个版本或者一个功能的提交，所以有时候我们不希望有过多的commit，比如已经commit到本地的lhw.php 文件，当我再次修改它的时候，我不希望这次的commit 纪录进log，这时可用使用amend：git commit --amend(会在指定的编辑器中打开，关闭后自动提交),注意只限于提交到本地并未推送到远端，如果已经推送到远端暂时没用想到办法。另外amend只适用于修正最后一次commit如果选择之前的某个版本，只能git reset --hard回到某个历史版本后在做amend。 查看修改可用使用： git show 指定hash值 ，而此处 git commit 不会产生新的log (具体想要几个commit还要根据具体的场景) ¶追随回归到过去的某一个版本 git reset --hard 彻底回退到某个版本，本地的源码也会变为上一个版本的内容。 git reset --soft 回滚一个commit状态。能回到add之后那里,回退的是commit的信息，不会回退代码。如果还要提交，直接commit即可 ¶gitignore 忽略版本控制 一个简单的例子忽略编辑器生成的 .idea文件 git rm -r --cached .idea/ ＃指目录，从缓存区中删除中添加 然后在 gitignore 配置中添加 .idea ,在提交。 ¶rebase 变基 由于分支上的commit合并到master的时候会产生新的commit,而rebase可以将分支上提交整合到master上，执行步骤如下： git checkout feacture 切换到发布分支 git rebase master 已master为基础 git checkout master 切回主干 git merge feacture 合并发布分支 ¶cherry-pick 挑拣commit 场景：假设我们有个稳定版本的分支，叫v2.0，另外还有个开发版本的分支v3.0，我们不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个v3.0中的功能到v2.0中，这里就可以使用cherry-pick了。 如把dev分支上的某些commit合并到release上 git checkout dev 当前的开发分支上 git checkout 0628fadz 从当前开发分支的0628fadz这个点开始检出代码 git branch test 为检出的代码创建test分支 git checkout test 切换test分支 git checkout release 切换到要合到的分支上 git cherry-pick 014de66 4dd1669 b6493af 803d021 将要合并的commit按先后顺序合并过来 git check-pick --abord 如果遇到冲突可以取消操作并返回到预序列状态 git status git check-pick --abord 可以连续使用 git push -u origin test git checekout release git merge test git pull git push 具体使用参照 ： https://git-scm.com/docs/git-cherry-pick 分支 分支的使用场景： 分支使用场景个人理解也就是git的开发规范，git开发规范有很多，如gitflow,感觉gitflow确实解决了许多问题，但同时又带出来了许多新的问题，如分支的最终管理最终看起来很乱。 简单的一套git分支规范：master(受保护的) ，dev(开发分支)，feacture(欲发布)，开发人员拉取dev分支在本地小步提交，开发完成合并到feacture，在由feacture合并到master 大范围的bug,可以创建一个bug分支. 新建分支： git branch -b lhwtest_1000 切换分支： git checkout -b lhwtest_1000 查看分支： git branch 提交到分支： git commit -m 'new touch file' 推送到指定 master 分支: git push origin lhwtest_1000 切换到主干： git checkout master 合并分支： git merge origin lhwtest_1000 最后推送到master: git push origin 单独revest某个文件 ： git checkout -- /app/lhw.php 分支开发完成没有bug后删除分支： git branch -d lhwtest_1000 注意分支开发过程中要不断的获取主干代码，保持本地与主干的代码同步, 获取最新的远端代码(否则无法推送到远端)，已保证远端代码和本地是否存在冲突 git fetch origin git pull origin pull 于 fetch 的区别： pull = fetch + merge , git fetch 的时候会从远端拉取一个隐藏master分支,使用git branch -r 查看，这个分支会与本地分支进行diff,然后决定是否需要合并，而 git pull 则直接进行合并 通常都说 git fetch 更加安全，但是实际工作中都默认使用 git pull 因为我们默认就是要已远端代码为准。 冲突解决 冲突场景：当在分支和主干修改并提交了相同文件的相同位置，在与主干合并时git会提示merge failed fix conficts and then commit the result,此时可以通过 git diff file查看文件冲突信息，并且用编辑器打开文件修改冲突信息，保存退出，重新 git add和 git commit git 命令别名 一 git 本身的配置文件 添加：git config --global alias.s status 删除：git config --global --unset alias.s 二 linux bash shell 的 .bash_profile 或者 zsh的 .zshrc 123456789101112alias ll=&#x27;ls -al&#x27;alias subl=&quot;&#x27;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&#x27;&quot;alias nano=&quot;subl&quot;alias des=&quot;cd ~/WebServer/Documents/&quot;alias gs=&quot;git status&quot;alias gc=&quot;git commit -m &quot;alias gaa=&quot;git add .&quot;alias gp=&quot;git push&quot;alias gl=&quot;git log --graph&quot;alias he=&quot;cd ~/hexo/hexo/lhw-hexo/&quot;alias pos=&quot;cd ~/hexo/hexo/lhw-hexo/source/_posts/&quot;export EDITOR=&quot;subl&quot; github 常用技巧 快捷键 ： shift + ? 查看一些流行的packgecg : https://github.com/trending pull代码的时候，经常会和本地有合并情况，一但合并便会产生新的分支，使分支线比较凌乱，解决办法： 命令行：git pull --rebase phpstorm 选择rebase sourcetree 勾选寅生选项 理解一些感念 一个本地仓库可以对应多个远程仓库，clone下来的仓库默认是与远端origin建立关联的,所以push的时候是可以直接push的， 使用 remote add 指向新的远程仓库。具体学习githubflow的流程，所以在push一个没用和远端建立关联的本地仓库时通常是要 push -u 指定远程仓库名称的。","raw":null,"content":null,"categories":[{"name":"git","slug":"git","permalink":"http://blog.nicexiangcun.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.nicexiangcun.com/tags/git/"}]},{"title":"常用sql总结","slug":"sql","date":"2016-06-28T14:18:35.000Z","updated":"2020-11-20T13:06:15.518Z","comments":true,"path":"2016/06/28/sql/","link":"","permalink":"http://blog.nicexiangcun.com/2016/06/28/sql/","excerpt":"¶🆔 sql查询前n天的日期 n&gt;=1\n12345678910111213141516select UNIX_TIMESTAMP(date_sub(curdate(),interval 1 day) ) ;+-----------------------------------------------------+| UNIX_TIMESTAMP(date_sub(curdate(),interval 1 day) ) |+-----------------------------------------------------+|                                          1466956800 |-----------------------------------------------------+select date_sub(curdate(),interval 1 day) ;+------------------------------------+| date_sub(curdate(),interval 1 day) |+------------------------------------+| 2016-06-27                         |+------------------------------------+\n¶查当天日期和时间\n123456789101112131415select CURDATE();+------------+| CURDATE()  |+------------+| 2016-06-28 |+------------+select NOW();+---------------------+| NOW()               |+---------------------+| 2016-06-28 22:29:48 |+---------------------+","text":"¶🆔 sql查询前n天的日期 n&gt;=1 12345678910111213141516select UNIX_TIMESTAMP(date_sub(curdate(),interval 1 day) ) ;+-----------------------------------------------------+| UNIX_TIMESTAMP(date_sub(curdate(),interval 1 day) ) |+-----------------------------------------------------+| 1466956800 |-----------------------------------------------------+select date_sub(curdate(),interval 1 day) ;+------------------------------------+| date_sub(curdate(),interval 1 day) |+------------------------------------+| 2016-06-27 |+------------------------------------+ ¶查当天日期和时间 123456789101112131415select CURDATE();+------------+| CURDATE() |+------------+| 2016-06-28 |+------------+select NOW();+---------------------+| NOW() |+---------------------+| 2016-06-28 22:29:48 |+---------------------+ ¶按月或按年 12345678910111213141516select YEAR(NOW());+-------------+| YEAR(NOW()) |+-------------+| 2016 |+-------------+select MONTH(NOW());+--------------+| MONTH(NOW()) |+--------------+| 7 |+--------------+ ¶一种不明白的sql insert 语句 12345678910111213$sql=&quot;INSERT INTO fee&quot; . &quot;(`create_time`, `create_uid`, `update_time`, `update_uid` &quot; . &quot;SELECT &quot; . &quot;2016-06-28&quot; . &quot;,10&quot; . &quot;,2016-06-28&quot; . &quot;,10&quot; . &quot;FROM DUAL &quot; . &quot;WHERE NOT EXISTS(SELECT * fee WHERE type=2 &quot; . &quot;and id=1 &quot; $pdo-&gt;query($sql);","raw":null,"content":null,"categories":[{"name":"mysql","slug":"mysql","permalink":"http://blog.nicexiangcun.com/categories/mysql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://blog.nicexiangcun.com/tags/sql/"}]},{"title":"php相关新特性","slug":"php-new-performance","date":"2016-06-25T13:52:10.000Z","updated":"2020-11-20T13:06:15.515Z","comments":true,"path":"2016/06/25/php-new-performance/","link":"","permalink":"http://blog.nicexiangcun.com/2016/06/25/php-new-performance/","excerpt":"数组相关\n¶不定长参数的一种传递方式 php5.6以上\n123456789101112function add(...$args)&#123;\tvar_dump($args)&#125;\t //这里传入的参数个数是可以改变的add(1, 2, 3, 4);\t //也可以传入数组，...会展开数组为多个参数$args = [1, 2, 3, 4];add(...$args);\n以往实现方式：\n1234567function()&#123;\t$args = func_get_args();\t$nums = func_num_args();&#125;","text":"数组相关 ¶不定长参数的一种传递方式 php5.6以上 123456789101112function add(...$args)&#123; var_dump($args)&#125; //这里传入的参数个数是可以改变的add(1, 2, 3, 4); //也可以传入数组，...会展开数组为多个参数$args = [1, 2, 3, 4];add(...$args); 以往实现方式： 1234567function()&#123; $args = func_get_args(); $nums = func_num_args();&#125; ¶多维数组的一种循环方式 12345678$array = [ [1, 2], [3, 4],];foreach ($array as list($a, $b)) &#123; echo &quot;A: $a; B: $b\\n&quot;;&#125; trait的使用 ¶trait 使用场景和目的 trait 使用目的 ： 一 代码重用 二 螺丝钉作用，像别人的代码或者已完成的代码 插入新的代码 yield 的使用 123456789101112131415161718//迭代器，每次只返回一个元素，而不是创建个大数组一次返回//例如下面的读取文件，每次只返回一行，而不是将整个文件都一次性读入内存//使用迭代器可以很好的节约内存function getLines($file)&#123; $f = fopen($file, &#x27;r&#x27;); try &#123; while ($line = fgets($f)) &#123; yield $line; &#125; &#125; finally &#123; fclose($f); &#125;&#125;foreach (getLines(&quot;file.txt&quot;) as $n =&gt; $line) &#123; echo $line;&#125;","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/tags/php/"}]},{"title":"google-故障自动发现自动恢复","slug":"google-devpos","date":"2016-06-07T14:13:00.000Z","updated":"2020-11-20T13:06:15.512Z","comments":true,"path":"2016/06/07/google-devpos/","link":"","permalink":"http://blog.nicexiangcun.com/2016/06/07/google-devpos/","excerpt":"","text":"service-level agreement 和 service-level objectives http://searchcio.techtarget.com/answer/Whats-the-difference-between-SLO-and-SLA 在保证 SLO 高可用的时候 保证系统的稳定性 和 产品交付速度。 （SRE Google运维解密） http://www.open-open.com/lib/view/open1479283593591.html 智能监控级别 告警 工单 日志 24 小时 技术服务 ＝》 技术服务手册","raw":null,"content":null,"categories":[],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://blog.nicexiangcun.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"phpStrom","slug":"phpStorm","date":"2016-06-04T15:10:45.000Z","updated":"2020-11-20T13:06:15.516Z","comments":true,"path":"2016/06/04/phpStorm/","link":"","permalink":"http://blog.nicexiangcun.com/2016/06/04/phpStorm/","excerpt":"¶idea\nhttp://idea.lanyus.com/\n¶phpStrom 常用快捷键：\nmac下\ncommand + ，打开配置项\ncommand + shift + a 列出所有通过 keymap 定义快捷键\ncommand + 1 隐藏和显示左侧工具栏\ncommand + e 最近打开的文件\ncommand + shift + o 搜索文件其实不用总是在左侧的工具栏中找，使用快捷键效率更高\ncommand + shift + F 全局搜索\ncommand + 7 显示类中的方法，右键可以将显示区域，移动到 左，上 右 不同区域\ncommand + l 跳转指定的行数\ncommand + x 删除当前行\ncommand + d 复制当前行\ncommand + b 跟踪变量至声明处\ncommand + option + l 格式化代码\ncommand + w 关闭当前窗口\ncommand + option + / 多行注释\ncommand + 6   查找//@todo标签\n常用工具条的显示和隐藏在view下编辑。 一些不常用的可以隐藏掉。\n¶多点编辑\n鼠标方式：按住 option ＋ 鼠标左键选中编辑内容\n快捷键 ：control + g  和  command ＋ control + g\n¶更改keymap 重置快捷键（按快捷键搜索）\n¶live templates\n¶主题配置：\n常规配置流程 command + ，呼出配置项 或者 preferences 进入 font 选择 scheme配置项 .","text":"¶idea http://idea.lanyus.com/ ¶phpStrom 常用快捷键： mac下 command + ，打开配置项 command + shift + a 列出所有通过 keymap 定义快捷键 command + 1 隐藏和显示左侧工具栏 command + e 最近打开的文件 command + shift + o 搜索文件其实不用总是在左侧的工具栏中找，使用快捷键效率更高 command + shift + F 全局搜索 command + 7 显示类中的方法，右键可以将显示区域，移动到 左，上 右 不同区域 command + l 跳转指定的行数 command + x 删除当前行 command + d 复制当前行 command + b 跟踪变量至声明处 command + option + l 格式化代码 command + w 关闭当前窗口 command + option + / 多行注释 command + 6 查找//@todo标签 常用工具条的显示和隐藏在view下编辑。 一些不常用的可以隐藏掉。 ¶多点编辑 鼠标方式：按住 option ＋ 鼠标左键选中编辑内容 快捷键 ：control + g 和 command ＋ control + g ¶更改keymap 重置快捷键（按快捷键搜索） ¶live templates ¶主题配置： 常规配置流程 command + ，呼出配置项 或者 preferences 进入 font 选择 scheme配置项 . 如果选择字体primaryfont，字体大小size或者间距linespacing的话，首先要save as 一份scheme . ¶自定义主题： daylerees.github.io 上选择一款自己喜欢的主题： 如选择 Potpourri，然后去 https://github.com/daylerees/colour-schemes/tree/master/jetbrains找到对应的主题文件如图： 进入选择具体的URL 进入命令行 1wget https://raw.githubusercontent.com/daylerees/colour-schemes/master/jetbrains/potpourri.icls 下载后重启 phpstrom 或者去 http://www.ideacolorthemes.org/themes/ 上选择喜欢的主题然后下载. 然后file倒入设置 将主题和左侧的工具栏色调保持一致方法： command + ，呼出配置项,然后搜索plugins,下载 color Ide 将主题字体和左侧的工具栏字体保持一致方法： ¶ 下载字体（ primary font） 方法： 以FiraCode字体为例 登陆 https://github.com/tonsky/FiraCode 下载 然后 倒入设置 ¶phpstrom 极简主义配置 一 隐藏各种 toolbar view 去掉 toolbar ，status Bar , Navigation Bar ,Tool Buttons 勾选 二 隐藏 breadcrumbs 呼出配置项，搜索 breadcrumbs ，去掉 show breadcrumbs 勾选项 三 隐藏文件名，保持当前窗口直有一个文件 文件右键，选择 tabs placement ,选择 none 恢复，呼出配置项 搜索 editor tabs 重新指定 placement 属性 四 配置主题 去选主题 http://daylerees.github.io 下载主题 https://github.com/daylerees/colour-schemes 选择 jetbrains ，具体参数以上步骤。 123cd ~/Library/Preferences/WebIde100/colorswget https://raw.githubusercontent.com/daylerees/colour-schemes/master/jetbrains/earthsong.icls 重启 phpstrom，呼出配置项，选择主题 ，save as 为 earthsong-theme，在重新设置字体等。 五 统一 left bar 的颜色 快捷键 command + shift + A 搜索 plugins 然后选择 config plugins，或者 呼出配置项 搜索 plugins,然后选择 Browse repositores … , 搜索color ide ,安装 六 两个重要的快捷键重置 （1）搜索文件 改为 command + P command + shift + A 搜索 keymap 进入设置项页面，首先将default copy一份后在重置，点击copy ,命名 lihongwei-keymap 搜索 command + shift + O , 然后 remove command + shift + O ,在 add keyboard shortcut ,输入新的快捷键，点 ok (2) 列出文件中的方法原快捷键 command + F12 改为 command + W 方法同上,注意 F12 同时要按住 Fn 七 快速创建文件 command + 上箭头 产看当前文件路径，可以通过左右箭头控制要创建文件所要在的目录然后，在按 command + N 调出新建文件选项框 八 模版 连续两下 shift 搜索 file template 或者 command + shift + A 搜索 file template (1) 新建模版名为 Eloquent Model ，Extension 为 php 12345678910111213#parse(&quot;PHP File Header.php&quot;)#if ($&#123;NAMESPACE&#125;)namespace $&#123;NAMESPACE&#125;;#endclass $&#123;NAME&#125; extends Eloquent &#123; protected \\$fillable = [];&#125; 然后去新建 Eloquent Model 九 动态模版 十 关于构造，set,get,doc 创建构造方法,设置属性值 ,获取属性值 ，文档注释 command + N 选择对应的选项 给构造方法做依赖注入快捷键 option + return (回车) 然后可以指定要构造的属性 ，前提条件，鼠标要在构造方法的括号内 构造的动态模版,搜索 live template ,选择 php ,新建 _c 12345public function __construct($ARGS$)&#123; $END$&#125; 最后difine PHP 使用 直接 _c ，然后 option + return","raw":null,"content":null,"categories":[{"name":"编辑器","slug":"编辑器","permalink":"http://blog.nicexiangcun.com/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[{"name":"phpstrom","slug":"phpstrom","permalink":"http://blog.nicexiangcun.com/tags/phpstrom/"}]},{"title":"RESTful API 设计要素","slug":"RESTful-API","date":"2016-06-03T13:51:45.000Z","updated":"2020-11-20T13:06:15.509Z","comments":true,"path":"2016/06/03/RESTful-API/","link":"","permalink":"http://blog.nicexiangcun.com/2016/06/03/RESTful-API/","excerpt":"RESTful API 设计\n¶协议\nAPI与用户的通信协议，HTTPS/HTTP。\n¶域名\nhttps://api.domain.com 专用api域名\n或者\nhttps://domain.com/api/ 将api作为一个模块\n¶版本（Versioning）\nhttps://api.example.com/v1/ 将版本号体现在URL上\n¶路径\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的&quot;集合&quot;（collection），所以API中的名词也应该使用复数。\nhttps://api.example.com/v1/article","text":"RESTful API 设计 ¶协议 API与用户的通信协议，HTTPS/HTTP。 ¶域名 https://api.domain.com 专用api域名 或者 https://domain.com/api/ 将api作为一个模块 ¶版本（Versioning） https://api.example.com/v1/ 将版本号体现在URL上 ¶路径 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的&quot;集合&quot;（collection），所以API中的名词也应该使用复数。 https://api.example.com/v1/article ¶HTTP动词 对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 下面是一些例子。 GET /article：列出所有文章 POST /article：新建一篇文章 GET /article/ID：获取一篇文章 PUT /article/ID：更新一篇文章 （提供文章的全部信息） PATCH /article/ID：更新一篇文章（提供文章的部分信息） DELETE /article/ID：删除一篇文章 GET /article/ID/tags：列出一篇文章的所有标签 DELETE /article/ID/tags/ID：删除一篇文章的一个标签 ¶过滤信息（Filtering） 如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?article_type_id=1：指定筛选条件 ¶状态码（Status Codes） 服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - []：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - []：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - []：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 ¶错误处理（Error handling） 如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: &quot;Invalid API key&quot;&#125; ¶返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 ¶Hypermedia API RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 123456&#123;&quot;link&quot;: &#123; &quot;rel&quot;: &quot;collection https://www.example.com/zoos&quot;, &quot;href&quot;: &quot;https://api.example.com/zoos&quot;, &quot;title&quot;: &quot;List of zoos&quot;, &quot;type&quot;: &quot;application/vnd.yourformat+json&quot;&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 12345&#123; &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;, &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;, // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。 1234&#123; &quot;message&quot;: &quot;Requires authentication&quot;, &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;&#125; 上面代码表示，服务器给出了提示信息，以及文档的网址。 ¶安全和其它 （1）API的身份认证应该使用OAuth 2.0框架。 （2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。","raw":null,"content":null,"categories":[{"name":"api","slug":"api","permalink":"http://blog.nicexiangcun.com/categories/api/"}],"tags":[{"name":"api","slug":"api","permalink":"http://blog.nicexiangcun.com/tags/api/"}]},{"title":"微服务领域设计范式-领域边界-领域职责","slug":"微服务-domain","date":"2016-06-01T13:55:53.000Z","updated":"2020-11-20T13:06:15.521Z","comments":true,"path":"2016/06/01/微服务-domain/","link":"","permalink":"http://blog.nicexiangcun.com/2016/06/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1-domain/","excerpt":"","text":"¶design step 确定领域边界，领域功能（所能暴露的接口功能） ， 领域模型 概要设计 api 详细设计 API 输入 输出 coding 重要的业务画一画流程图 ¶服务拆分 就现在的软件工程来说，都可以通过抽象来优雅的解决问题。 重点：明确职责，关注点分离 。 不要重复早轮子，你自己造的轮子是自己一个人拍着脑袋瓜造的，结对编程或者一个屋子就一台电脑几个人轮溜写代码，有足够多的眼睛，就可以让问题浮现。 重要的业务场景一定要化流程图。结对编程。 追求单个文件代码行数，还是文件个数，取决你是否 能够快速描述一段代码的流程 服务拆分：代码按照业务 水平拆，结对编程 垂直拆，这里可能涉及到devpos 的反模式。 ¶pass 云平台 part component ¶Apigetway ¶服务注册中心 服务注册中心是服务发现的核心。它保存了各个可用服务实例的网络地址（IP Address和Port）。服务注册中心必须要有高可用性和实时更新功能。 服务发现的核心是服务注册中心。服务注册中心保存了各个服务可用的实例的相关信息。服务注册中心提供了管理API和查询API。使用管理API进行服务注册、注销。系统的其他组件可以通过查询API来获得当前可用的服务实例信息。 有两种主要的服务发现方式：客户端发现（client-side service discovery）和服务端发现（ server-side discovery）。在使用客户端服务发现的方式中，客户通过查询服务注册中心，选择一个可用的服务实例。在使用服务器端发现系统中，客户访问Router/load balancer，通过Router/load balancer查询服务注册中心，并将请求转发到一个可用服务实例上。 服务注册和注销的方式也有两种。一种是服务自己主动的将自己注册到服务注册中心，称为self-registration。另一种是通过其他组件来处理服务的注册和注销，称为third-party registration。 不同语言之间可以通过各种代理实现服务注册。 ¶problem 程序层级目录结构：尽量避免已程序层面建立目录 ， 应从业务角度组建目录结构，并且保证功能文件的高内聚低耦合 。 支持门面包装服务。 ¶Minimum Viable Product 是一种避免开发出客户并不真正需要的产品的开发策略。该策略的基本想法是，快速地构建出符合产品预期功能的最小功能集合，这个最小集合所包含的功能足以满足产品部署的要求并能够检验有关客户与产品交互的关键假设[1]。该概念由Eric Ries在其著作《精益创业实战》中提出，用最快、最简明的方式建立一个可用的产品原型，这个原型要表达出你产品最终想要的效果，然后通过迭代来完善细节。 http://www.jianshu.com/p/2e1ca1c22b65 http://www.woshipm.com/pd/237443.html","raw":null,"content":null,"categories":[{"name":"devops","slug":"devops","permalink":"http://blog.nicexiangcun.com/categories/devops/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://blog.nicexiangcun.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"用异或运算实现一种加密解密方法","slug":"php-sign","date":"2016-05-29T11:31:42.000Z","updated":"2020-11-20T13:06:15.515Z","comments":true,"path":"2016/05/29/php-sign/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/29/php-sign/","excerpt":"先来介绍PHP几个函数\n1234ctype_alpha    //检查字符串是否全是字母ctype_lower    //检查字符串是否小写ctype_upper    //检查字符串是否大写ctype_digit    //检查字符串是否全是数字","text":"先来介绍PHP几个函数 1234ctype_alpha //检查字符串是否全是字母ctype_lower //检查字符串是否小写ctype_upper //检查字符串是否大写ctype_digit //检查字符串是否全是数字 1234567891011121314151617function StrCode($string, $action =&#x27;ENCODE&#x27;) &#123; $action!= &#x27;ENCODE&#x27; &amp;&amp; $string = base64_decode($string); $code= &#x27;&#x27;; $key= &#x27;abcdefghijklmnopqrstuvwxyz&#x27;; $keyLen= strlen($key); $strLen= strlen($string); for($i = 0; $i &lt; $strLen; $i++) &#123; $k= $i % $keyLen; /* 1 ^ 1 (加密因子密钥) 0 ^ 1 = 1 * 0 ^ 1 (加密因子密钥) 1 ^ 1 = 0 * 1 ^ 0 (加密因子密钥) 1 ^ 0 = 1 * 0 ^ 0 (加密因子密钥) 0 ^ 0 = 0 */ $code.= $string[$i] ^ $key[$k]; &#125; return($action != &#x27;DECODE&#x27; ? base64_encode($code) : $code);&#125;","raw":null,"content":null,"categories":[{"name":"php","slug":"php","permalink":"http://blog.nicexiangcun.com/categories/php/"}],"tags":[{"name":"sign","slug":"sign","permalink":"http://blog.nicexiangcun.com/tags/sign/"}]},{"title":"memcache","slug":"memcache","date":"2016-05-29T11:20:44.000Z","updated":"2020-11-20T13:06:15.514Z","comments":true,"path":"2016/05/29/memcache/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/29/memcache/","excerpt":"\nmemcache 一致性hash\n\n123456789101112131415161718// memcache一致性hash实现,为了解决多台memcache服务器setcache的时候增加或删除节点导致,缓存瞬间命不中问题 通话hash算法将节点映射到一个圆环上// 定义循环链表 长度 为2的32 次方$circle = array(0,1,2,3,4,5,6,7,8,9,10,11);//将3台memcache 服务器节点映射的圆环上$circle[&#x27;3&#x27;] = &#x27;192.168.10.1&#x27;;$circle[&#x27;6&#x27;] = &#x27;192.168.10.2&#x27;;$circle[&#x27;9&#x27;] = &#x27;192.168.10.3&#x27;;//建立cache请求$key = 2;foreach ($circle as $key=&gt;$val)&#123;\tif(strlen($circle[$key])!=1)&#123;\t\t$cache-&gt;connect($circle[$key],&#x27;11211&#x27;);\t\t$cache-&gt;set($key,&#x27;val&#x27;);break;\t&#125;&#125;","text":"memcache 一致性hash 123456789101112131415161718// memcache一致性hash实现,为了解决多台memcache服务器setcache的时候增加或删除节点导致,缓存瞬间命不中问题 通话hash算法将节点映射到一个圆环上// 定义循环链表 长度 为2的32 次方$circle = array(0,1,2,3,4,5,6,7,8,9,10,11);//将3台memcache 服务器节点映射的圆环上$circle[&#x27;3&#x27;] = &#x27;192.168.10.1&#x27;;$circle[&#x27;6&#x27;] = &#x27;192.168.10.2&#x27;;$circle[&#x27;9&#x27;] = &#x27;192.168.10.3&#x27;;//建立cache请求$key = 2;foreach ($circle as $key=&gt;$val)&#123; if(strlen($circle[$key])!=1)&#123; $cache-&gt;connect($circle[$key],&#x27;11211&#x27;); $cache-&gt;set($key,&#x27;val&#x27;);break; &#125;&#125; 1、一致性hash算法只是帮我们减少cache集群中的机器数量增减的时候，cache的数据能进行最少重建。只要cache集群的server数量有变化，必然产生数据命中的问题 2、对于数据的分布均衡问题，通过虚拟节点的思想来达到均衡分配。当然，我们cache server节点越少就越需要虚拟节点这个方式来均衡负载。 3、我们的cache客户端根本不会维护一个map来记录每个key存储在哪里，都是通过key的hash和cacheserver（也许ip可以作为参数）的hash计算当前的key应该存储在哪个节点上。 4、当我们的cache节点崩溃了。我们必定丢失部分cache数据，并且要根据活着的cache server和key进行新的一致性匹配计算。有可能对部分没有丢失的数据也要做重建… 5、至于正常到达数据存储节点，如何找到key对应的数据，那就是cache server本身的内部算法实现了，此处不做描述。 这里只是针对数据的存储方式以及提取方式进行了流程展示。","raw":null,"content":null,"categories":[{"name":"memcache","slug":"memcache","permalink":"http://blog.nicexiangcun.com/categories/memcache/"}],"tags":[{"name":"memcache","slug":"memcache","permalink":"http://blog.nicexiangcun.com/tags/memcache/"}]},{"title":"Python基础数据类型","slug":"python-base","date":"2016-05-29T10:50:03.000Z","updated":"2020-11-20T13:06:15.516Z","comments":true,"path":"2016/05/29/python-base/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/29/python-base/","excerpt":"12345678910111213141516#!/bin/python#ecoding=utf-8#倒入所需要的模块import timeimport osimport md5import random＃打印语句print &quot;你好!&quot;#变量的申明，前面不用加修饰类型#--int类型intA = 1;intB = 2;","text":"12345678910111213141516#!/bin/python#ecoding=utf-8#倒入所需要的模块import timeimport osimport md5import random＃打印语句print &quot;你好!&quot;#变量的申明，前面不用加修饰类型#--int类型intA = 1;intB = 2; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#int类型和String 不能直接用+号，需要转成String再拼接。print &quot;values:&quot; + str(intA + intB);#boolean 类型 要注意里面的大小写 True和Falsename = True#if语句，需要一起和for注意的是后面加冒号（:）if name== True: print &quot;true&quot;else: print &quot;false&quot; #forfor i in range(1,5,1): print i;#方法（也在函数的叫法）的申明。同样不要忘记了冒号，因为Python不像其他语言那样还要括号，是按严格的格式来区分的所以个人也比较喜欢在方法后面加个结束注释。def printName(name): print name print len(name) #end fun printNameprintName(&quot;my name is xxx&quot;)#容器,习惯Java的朋友肯定也会像我一样想到数组（String[]）、集合（List、Map）Python也同样有类似的类型。#列表List，类型Java中的集合List a = [1,2,3,&quot;array&quot;]a.append(&quot;insert values&quot;)a.insert(0, 0)for v in a: print v #元组 trupe，和Java中的数组类似 array = (&quot;array1&quot;,&quot;array2&quot;,&quot;array3&quot;)for arr in array: print arr#Dict 和Java中的map类似mapValues = &#123;&quot;name&quot;:&quot;text123&quot;,&quot;age&quot;:18&#125;print mapValues.get(&#x27;age&#x27;)print mapValues[&#x27;name&#x27;]#time函数，需要在头部添加 import timetime.sleep(1.5) #这里的单位是秒，和Java毫秒不一样。当然可以传入小数print &quot;print content&quot;print time.time() print time.strftime(&#x27;%Y-%m-%d %H:%M:%d&#x27;) # Java 中SimpleDateFormat#os对系统一些操作print os.name #使用的平台print os.getcwd() #当前工作目录files = os.listdir(&#x27;E:\\software&#x27;)#for f in files:#print f#os.remove(&#x27;D://Test.java&#x27;);#MD5m = md5.new(&quot;test123&quot;)print m.digest() #16位print m.hexdigest() #32位#randomprint random.random()#file textFile = open(&quot;D:\\\\test.txt&quot;);for line in textFile.readlines(): print linefile.close()","raw":null,"content":null,"categories":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.nicexiangcun.com/tags/python/"}]},{"title":"Yii匿名函数","slug":"Yiidaytoday","date":"2016-05-28T04:34:35.000Z","updated":"2020-11-20T13:06:15.510Z","comments":true,"path":"2016/05/28/Yiidaytoday/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/28/Yiidaytoday/","excerpt":"","text":"Yii2匿名函数小应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125namespace console\\controllers;use Yii;class TestController extends \\yii\\console\\Controller&#123; public $enableCsrfValidation = false; public function actionTest() &#123; //在循环中使用闭包时,要注意如果一个变量在闭包中改变了值,到下一次循环时,不会被释放 $type = []; $flg = 0; //要改变的变量 或者对象 $data = [ [&#x27;type&#x27;=&gt;&#x27;1&#x27;,&#x27;one_level&#x27;=&gt;100,&#x27;two_lever&#x27;=&gt;200,&#x27;phone&#x27;=&gt;&#x27;15510337665&#x27; ], [&#x27;type&#x27;=&gt;&#x27;1&#x27;,&#x27;one_level&#x27;=&gt;100,&#x27;two_lever&#x27;=&gt;200,&#x27;phone&#x27;=&gt;&#x27;15510337665&#x27; ], [&#x27;type&#x27;=&gt;&#x27;2&#x27;,&#x27;one_level&#x27;=&gt;100,&#x27;two_lever&#x27;=&gt;200,&#x27;phone&#x27;=&gt;&#x27;15510337665&#x27; ], [&#x27;type&#x27;=&gt;&#x27;1&#x27;,&#x27;one_level&#x27;=&gt;100,&#x27;two_lever&#x27;=&gt;200,&#x27;phone&#x27;=&gt;&#x27;15510337665&#x27; ], [&#x27;type&#x27;=&gt;&#x27;2&#x27;,&#x27;one_level&#x27;=&gt;100,&#x27;two_lever&#x27;=&gt;200,&#x27;phone&#x27;=&gt;&#x27;15510337665&#x27; ], [&#x27;type&#x27;=&gt;&#x27;1&#x27;,&#x27;one_level&#x27;=&gt;100,&#x27;two_lever&#x27;=&gt;200,&#x27;phone&#x27;=&gt;&#x27;15510337665&#x27; ], [&#x27;type&#x27;=&gt;&#x27;2&#x27;,&#x27;one_level&#x27;=&gt;100,&#x27;two_lever&#x27;=&gt;200,&#x27;phone&#x27;=&gt;&#x27;15510337665&#x27; ], ] ; foreach($data as $key=&gt;$val)&#123; $this-&gt;filter($val , $flg ,function($ret) use ($type)&#123; file_put_contents(&#x27;lhw.log&#x27;,var_export($ret,true).PHP_EOL,FILE_APPEND); &#125;); &#125; &#125; private function filter(array $arr,$flg,$fun) &#123; if($arr[&#x27;type&#x27;] == &#x27;1&#x27;)&#123; $flg = 500; //下次循环500不会从内存中释放 $arr[&#x27;one_level&#x27;] = $arr[&#x27;one_level&#x27;] + 1000; $arr[&#x27;flg&#x27;] = $flg + $arr[&#x27;one_level&#x27;]; &#125; $fun($arr); &#125; //使用过滤 public function actionFilter() &#123; //习惯使用list 指定获取索引数组值 list($value, $property, $cType) = [&#x27;dd&#x27;,&#x27;33&#x27;,&#x27;32&#x27;]; //使用匿名函数过滤元素 $filterItem[&#x27;andor&#x27;] = &#x27;or&#x27;;//过滤元素 $andor = call_user_func(function($default) use($filterItem) &#123; if ((array_key_exists(&#x27;andor&#x27;, $filterItem)) &amp;&amp; (strtolower($filterItem[&#x27;andor&#x27;]) == &#x27;or&#x27;)) &#123; return &quot;OR&quot;; &#125; return $default; &#125;, &quot;AND&quot;); //结合使用 list($val) = [call_user_func(function($default) use ($filterItem)&#123; if ((array_key_exists(&#x27;andor&#x27;, $filterItem)) &amp;&amp; (strtolower($filterItem[&#x27;andor&#x27;]) == &#x27;or&#x27;)) &#123; return &quot;OR&quot;; &#125; return $default; &#125;,&#x27;default&#x27;)]; echo $val; &#125; //如果整个action 都要求返回json 可以在进action 之前 判断转换如： public function beforeAction($action) &#123; if (Yii::$app-&gt;request-&gt;isAjax) &#123; Yii::$app-&gt;response-&gt;format = Response::FORMAT_JSON; &#125; return parent::beforeAction($action);//必须return &#125; public function actionApi() &#123; return [&#x27;name&#x27;=&gt;&#x27;lwh&#x27;] ;//自动转换成json &#125; //使用模型对象添加数据的一种方法 public function actionAdd() &#123; SmsMessage::initSms( $user, [$user-&gt;real_name, date(&#x27;Y-m-d H:i&#x27;, $draw-&gt;created_at), $draw-&gt;money, &#x27;T+1&#x27;, Yii::$app-&gt;params[&#x27;contact_tel&#x27;]], Yii::$app-&gt;params[&#x27;sms&#x27;][&#x27;tixian_apply&#x27;] )-&gt;save(false); &#125; //数据模型 public static function initSms(User $user, array $message, $template_id, $level = self::LEVEL_MIDDLE) &#123; $smsmsg = new self([ &#x27;uid&#x27; =&gt; $user-&gt;id, &#x27;template_id&#x27; =&gt; $template_id, &#x27;mobile&#x27; =&gt; $user-&gt;mobile, &#x27;level&#x27; =&gt; $level, &#x27;message&#x27; =&gt; json_encode($message), ]); return $smsmsg; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"Yii","slug":"Yii","permalink":"http://blog.nicexiangcun.com/categories/Yii/"}],"tags":[{"name":"Yii","slug":"Yii","permalink":"http://blog.nicexiangcun.com/tags/Yii/"}]},{"title":"designpatterns","slug":"designpatterns","date":"2016-05-22T06:48:32.000Z","updated":"2020-11-20T13:06:15.511Z","comments":true,"path":"2016/05/22/designpatterns/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/22/designpatterns/","excerpt":"组合模式\n组合模式相关概念：依赖注入、控制反转\n¶依赖注入概念：\n一个类如果想使用另一类中的某些方法或者属性，除了继承外，也可以使用组合，组合的含义是将继承或者在构造触发new的过程，提到类的外面去做，采用依赖注入的方式传递对象。（消除了依赖）降低代码耦合程度，提高项目的可维护性。","text":"组合模式 组合模式相关概念：依赖注入、控制反转 ¶依赖注入概念： 一个类如果想使用另一类中的某些方法或者属性，除了继承外，也可以使用组合，组合的含义是将继承或者在构造触发new的过程，提到类的外面去做，采用依赖注入的方式传递对象。（消除了依赖）降低代码耦合程度，提高项目的可维护性。 这种注入的缺陷在于：我们的业务层对依赖单元的实例化代码是一个重复、繁琐的过程。 ¶控制反转概念： 将类（上层）,所依赖的单元（下层）的实例化过程交由第三方来实现。一个简单的特征，就是类中不对所依赖的单元有诸如 $component = new yii\\component\\SomeClass（） 的实例化语句。 Yii中为什么要使用DI，像上面所所说的，一个类如果想使用另一类中的某些方法或者属性，除了继承外，也可以使用组合，也就是DI模式，其本质现象就是，我访问我所依赖的单元对象中成员方法或者属性时就像访问本类一样。因为我已经通过DI将本类所依赖的单元注入到了本类中。 ¶什么时候是有继承，什么时候使用接口 继承意味着公用，公用的含义： 一 公用的功能、逻辑，意味着具体的，可封装的 二 公用的特性，但是表现不一样，意味着抽象，抽象类 基于以上可以使用继承。 接口，当某些实例拥有一部分区别于其他同类实例的特性，那么这些特性是不适合被这些类继承过来的，那么这些特性可以使用接口，只有适用这些特性的类来实现这个接口。 ¶策略 和 多态 ¶工厂 和 抽象工厂","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.nicexiangcun.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Yii_install","slug":"Yii-install","date":"2016-05-17T13:37:39.000Z","updated":"2020-11-20T13:06:15.509Z","comments":true,"path":"2016/05/17/Yii-install/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/17/Yii-install/","excerpt":"用composer 安装Yii2\n安装依赖包方式，获取定义的依赖到你的本地项目，只需要调用 composer.phar 运行 install 命令如。\n1php composer.phar install\n安装时需要githug账号，下载时需要token,可以通过 git  ssh-keygen 生成 token秘钥\n一 先下载 advanced 模板  https://github.com/yiisoft/yii2-app-advanced\n二 dos cd 到 advanced 模板下 ：执行\n12php -r &quot;readfile(&#x27;https://getcomposer.org/installer&#x27;);&quot; | php   //下载 composer.phar \n三 准备插件\n1php composer.phar global require &quot;fxp/composer-asset-plugin:1.0.0&quot;\n或者\n1php composer.phar global require &quot;fxp/composer-asset-plugin:~1.1.1&quot;","text":"用composer 安装Yii2 安装依赖包方式，获取定义的依赖到你的本地项目，只需要调用 composer.phar 运行 install 命令如。 1php composer.phar install 安装时需要githug账号，下载时需要token,可以通过 git ssh-keygen 生成 token秘钥 一 先下载 advanced 模板 https://github.com/yiisoft/yii2-app-advanced 二 dos cd 到 advanced 模板下 ：执行 12php -r &quot;readfile(&#x27;https://getcomposer.org/installer&#x27;);&quot; | php //下载 composer.phar 三 准备插件 1php composer.phar global require &quot;fxp/composer-asset-plugin:1.0.0&quot; 或者 1php composer.phar global require &quot;fxp/composer-asset-plugin:~1.1.1&quot; 要保证 composer 版本一致 升级 1.1.1 更新命令 12composer self-updatecomposer update 四 安装 1php composer.phar create-project --prefer-dist --stability=dev yiisoft/yii2-app-advanced ../yii2test 五 最后一步：初始化我们的应用,初始化是在你创建的yii2test目录下 执行 init命令 选0 按y 最后Yii2 添加新应用需要注意的地方 以新加wap 站为例 一 将 frontend 前台复制一份 改名wap(注意把里面所有文件的命名空间改为 wap的) 二 将common/config bootstrap 新加一份 wap 的别名 三 将common/config main.php 新加路由修改配置（不使用默认路由规则） 将改过来的wap 下的config 的main.php 中的 id 和controllerNamespace 等改正确 1234&#x27;urlManager&#x27; =&gt; [ &#x27;enablePrettyUrl&#x27; =&gt; true, &#x27;showScriptName&#x27; =&gt; false,] 四：修改apache 路由规则 隐藏点 index.php RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]","raw":null,"content":null,"categories":[{"name":"Yii","slug":"Yii","permalink":"http://blog.nicexiangcun.com/categories/Yii/"}],"tags":[{"name":"Yii","slug":"Yii","permalink":"http://blog.nicexiangcun.com/tags/Yii/"}]},{"title":"svn 搭建","slug":"svn","date":"2016-05-17T13:25:12.000Z","updated":"2020-11-20T13:06:15.518Z","comments":true,"path":"2016/05/17/svn/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/17/svn/","excerpt":"ubuntu svn 搭建步骤：\n¶🐷 安装\n1sudo apt-get install subversion\n¶建立版本库\n1234sudo mkdir -p /data/repossudo svnadmin create /data/repos/clientsudo svnadmin create /data/repos/serversudo svnadmin create /data/repos/api","text":"ubuntu svn 搭建步骤： ¶🐷 安装 1sudo apt-get install subversion ¶建立版本库 1234sudo mkdir -p /data/repossudo svnadmin create /data/repos/clientsudo svnadmin create /data/repos/serversudo svnadmin create /data/repos/api ¶配置文件 123456789101112131415sudo vi authz[/]lhw=rwzhang=rwsudo vi passwd[users]zhang=123456lhw=123456sudo vi svnserve.confanon-access = none auth-access = writepassword-db = passwdrealm = /data/repos ¶启动svn (注意目录为版本仓库的上一级目录) 1sudo svnserve -d -r /data/repos/ ¶杀掉svn 1killall svnserve 如果出现： 123svn: warning: cannot set LC_CTYPE localesvn: warning: environment variable LC_CTYPE is UTF-8svn: warning: please check that your locale name is correct 解决： 参考 http://stackoverflow.com/questions/11300633/svn-cannot-set-lc-ctype-locale 12345sudo apt-get install language-pack-en-basesudo locale-gen UTF-8sudo locale-gen en_GB.UTF-8sudo locale-gen en_US.UTF-8","raw":null,"content":null,"categories":[{"name":"svn","slug":"svn","permalink":"http://blog.nicexiangcun.com/categories/svn/"}],"tags":[{"name":"svn","slug":"svn","permalink":"http://blog.nicexiangcun.com/tags/svn/"}]},{"title":"nginx","slug":"nginx","date":"2016-05-15T05:19:51.000Z","updated":"2020-11-20T13:06:15.514Z","comments":true,"path":"2016/05/15/nginx/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/15/nginx/","excerpt":"nginx 信号控制\n\n¶查看服务端口列表项\nnetstat -antp (p是显示那个进程 和进程号)\n¶查看进程\nps -aux | grep 80  （httpd）\n¶信号控制\n使用参数INT是紧急杀掉进程非常暴力（特殊场景不推荐），QUIT 优雅的杀掉进程，等待work主进程接收处理所有请求后在杀掉。HUP平滑的读取配置文件，不用重启nginx就能使配置文件生效（很重要），USR1 告诉nginx 写入log 往新建的文件中写（在备份log日志时必须要用，因为linux中的文件存放地址是通过innode号存储的，当mv 备份文件的时候只是变化名字而已，而innode号依然不变，所有nginx依然往原始的innode号文件写入日志，此时需要用信号量USR1）。","text":"nginx 信号控制 ¶查看服务端口列表项 netstat -antp (p是显示那个进程 和进程号) ¶查看进程 ps -aux | grep 80 （httpd） ¶信号控制 使用参数INT是紧急杀掉进程非常暴力（特殊场景不推荐），QUIT 优雅的杀掉进程，等待work主进程接收处理所有请求后在杀掉。HUP平滑的读取配置文件，不用重启nginx就能使配置文件生效（很重要），USR1 告诉nginx 写入log 往新建的文件中写（在备份log日志时必须要用，因为linux中的文件存放地址是通过innode号存储的，当mv 备份文件的时候只是变化名字而已，而innode号依然不变，所有nginx依然往原始的innode号文件写入日志，此时需要用信号量USR1）。 kill -INT 进程号 杀掉nginx进程，ps -aux | greap nginx查看进程号 小技巧：有时候经常需要查看 nginx 主进程号， 可以查看pid的存放文件，这样用的时候直接如： 1kill -INT &#x27;cat /usr/local/var/niginx/log/nginx.pid&#x27; ¶nginx第二种启动方法 nginx -s reload 重启 nginx -s stop 停止 nginx -s reopen 重新读取配置文件 nginx -t 查看配置文件配置是否正确 ¶虚拟主机配置 Nginx 的虚拟主机就是配置 http 中的 server 块。 可以基于 域名、端口、和ip 主要 三项： listen、server_name、location&#123; root:&#125; Location 定位配置块 三种: 精准匹配（精准匹配最好不要匹配跟目录，会默认追加索引文件可能导致多重定位，如循环重定向死循环等） 正则匹配 普通匹配：普通匹配优先级最高，言外之意是正则会覆盖普通匹配的结果 ，普通匹配如果命中多个则最长的匹配结果先记下来，然后走正则匹配如果正则没有匹配到这返回这个最长的匹配结果，静态文件的动静分离 可以用 location 将静态文件 放到 应用以外的目录 然后用 loaction 正则定位。 备注：当发现 404 时 要记住看下log 日志 是去哪个目录没找到 非常有用 。 ¶日志管理： 首先日志可以辅助排错，nginx可以针对不同的server配置不同的log位置和log日志格式 ：默认是main 格式，大概是 来访者ip ，访问方式 …… 一个日志的切割管理bash: 12345678910#!/bin/bashlogpath = /usr/local/nginx/log/access.logtopath = /data/log/$(date -d yesterday + &quot;%Y%m&quot;)mkdir -p $topathbathpath = $topaht/$(date -d yesterday + &quot;%Y%m%d&quot;).logmv $logpath $bathpahttouch $logpathkill USR1 /usr/run/nginx.pidsh ./run.sh","raw":null,"content":null,"categories":[{"name":"webserver","slug":"webserver","permalink":"http://blog.nicexiangcun.com/categories/webserver/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://blog.nicexiangcun.com/tags/nginx/"}]},{"title":"Yii2","slug":"Yii2","date":"2016-05-13T07:17:31.000Z","updated":"2020-11-20T13:06:15.510Z","comments":true,"path":"2016/05/13/Yii2/","link":"","permalink":"http://blog.nicexiangcun.com/2016/05/13/Yii2/","excerpt":"Yii2 登录机制和验证码的使用\n\n¶🐿️ Yii2登录\n如果要通过gii自定义生产user模型的话(不适用默认的user)，要在当前应用的config/main 下配置user组件路径如：\n1234&#x27;user&#x27; =&gt; [        &#x27;identityClass&#x27; =&gt; &#x27;common\\models\\user\\Diyouuser&#x27;,        &#x27;enableAutoLogin&#x27; =&gt; true,    ],\n接下来在`loginForm` 模型下 `use common\\models\\user\\Diyouuser;` 使用该模型\n\n验证规则写在 loginForm 下 如：\n","text":"Yii2 登录机制和验证码的使用 ¶🐿️ Yii2登录 如果要通过gii自定义生产user模型的话(不适用默认的user)，要在当前应用的config/main 下配置user组件路径如： 1234&#x27;user&#x27; =&gt; [ &#x27;identityClass&#x27; =&gt; &#x27;common\\models\\user\\Diyouuser&#x27;, &#x27;enableAutoLogin&#x27; =&gt; true, ], 接下来在`loginForm` 模型下 `use common\\models\\user\\Diyouuser;` 使用该模型 验证规则写在 loginForm 下 如： 12345678910111213141516171819public function rules()&#123; return [ [[&#x27;username&#x27;, &#x27;password&#x27;], &#x27;required&#x27;], [&#x27;password&#x27;, &#x27;validatePassword&#x27;], ];&#125;public function validatePassword($attribute, $params)&#123; if (!$this-&gt;hasErrors()) &#123; $user = $this-&gt;getUser(); if (!$user || $user-&gt;password != md5($this-&gt;password)) &#123; $this-&gt;addError($attribute, &#x27;用户名或者密码错误&#x27;); &#125; &#125;&#125; 在触发登录前要先验证validatePassword的话 必须触发 Yii的 $model-&gt;validate() 如果要添加自定义validate的话，也必须在触发login前调用自定义的mycustvalidate， validate 都验证通过后 在触发 Yii 的 login : Yii::$app-&gt;user-&gt;login($user); $user 是 common\\models\\user\\Diyouuser;组件的一个组件而且必须实现 IdentityInterface 这个接口 ¶Yii2 验证码相关 使用验证码步骤: 在使用的相关类中重写 Controller中的actions方法主要是自定义配置。 要做Model的验证规则中指定使用的路径位置如 : ['verify', 'captcha','captchaAction'=&gt;'login/captcha'] 在视图中使用widget 部件 如： 1234567891011121314151617&lt;?= $form-&gt;field($model, &#x27;verify&#x27;, [ ])-&gt;widget(yii\\captcha\\Captcha::className(), [ &#x27;template&#x27; =&gt; &#x27;&lt;div class=&quot;input-group&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-picture&quot;&gt;&lt;/span&gt; &lt;/span&gt;&#123;input&#125; &lt;span class=&quot;input-group-addon&quot;style=&quot;margin:0;padding:0&quot;&gt; &#123;image&#125; &lt;/span&gt; &lt;/div&gt;&#x27;, &#x27;imageOptions&#x27; =&gt; [ &#x27;alt&#x27; =&gt; &#x27;点击换图&#x27;, &#x27;title&#x27; =&gt; &#x27;点击换图&#x27;, &#x27;style&#x27; =&gt; &#x27;cursor:pointer&#x27; ], &#x27;captchaAction&#x27; =&gt; &#x27;login/captcha&#x27;, ])-&gt;label(false) ?&gt; ¶Yii2 中的分页 1234567891011121314151617&lt;nav&gt;&lt;?php$this-&gt;widget(&#x27;CLinkPager&#x27;,array( &#x27;header&#x27;=&gt;&#x27;&#x27;, &#x27;firstPageLabel&#x27; =&gt; &#x27;首页&#x27;, &#x27;lastPageLabel&#x27; =&gt; &#x27;末页&#x27;, &#x27;prevPageLabel&#x27; =&gt; &#x27;上一页&#x27;, &#x27;nextPageLabel&#x27; =&gt; &#x27;下一页&#x27;, &#x27;pages&#x27; =&gt; $pager, &#x27;maxButtonCount&#x27;=&gt;8, &#x27;cssFile&#x27;=&gt;false, &#x27;htmlOptions&#x27; =&gt;array(&quot;class&quot;=&gt;&quot;pagination&quot;), &#x27;selectedPageCssClass&#x27;=&gt;&quot;active&quot; ) );?&gt;&lt;/nav&gt; 分页必须在&lt;nav&gt;里 htmlOptions选项是必须的，他指定了yii生成的分页div的class名称，在这里我们使用bootstrap的class名 selectedPageCssClass选项指定了当前选中页的样多，在这里我们使用bootstrap的active 另外还需要把cssFile设为false，不加载分页css样式文件 Yii2事件 ¶Yii2中的事件原理 Yii2中的事件handle,就是一段回调处理程序，说白了handle就是回调函数的应用，php中回调的应用几种方式： 一. 一个全局的函数 如 1234call_usr_func(&#x27;funcname&#x27;,&#x27;args&#x27;)$person = new Person;// 使用PHP全局函数作为handler来进行绑定$person-&gt;on(Person::EVENT_GREET, &#x27;person_say_hello&#x27;); 二. 对象中的成员方法如果: 12// 使用对象$obj的成员函数say_hello来进行绑定$person-&gt;on(Person::EVENT_GREET, [$obj, &#x27;say_hello&#x27;]); 三.类中的静态方法： 12// 使用类Greet的静态成员函数say_hello进行绑定$person-&gt;on(Person::EVENT_GREET, [&#x27;app\\helper\\Greet&#x27;, &#x27;say_hello&#x27;]); 四. 匿名函数： 12345// 使用匿名函数$person-&gt;on(Person::EVENT_GREET, function ($event) &#123; echo &#x27;Hello&#x27;;&#125;); Yii 在绑定事件的时候 其实就是 维护一个 _event 事件数组，通过on 方法 按照规则 将 handle和args插入到事件数组里，当调用trigger时候，其实就是循环 _enevt 然后 通过 call_user_func_array()触发 回调，回调的逻辑要在 ，定义好的 以上四种 中handdle 中实现。 Yii2 Layout ¶Layout布局 在controall 中使用布局文件方法： 1234567Public function init()&#123; Parent:: init(); //在当前controll 指定布局文件 $this-&gt;layout = &#x27;custmain&#x27;； //在当前controll不使用布局文件 $this-&gt;layout = false;&#125; 然后在controll 渲染视图前 在指定要重新定义的layout 1234Public function actionTest()&#123; $this-&gt;layout = &#x27;main&#x27;； $this-&gt;render();&#125; 布局文件可以嵌套使用：原理是从内往外逐层传递$content 变量 例如： Testlayout 中指定 123456789&lt;?php $this-&gt;beginContent(&#x27;@/app/view/layout/main&#x27;) ?&gt;&lt;div&gt; Cust content&lt;/div&gt;&lt;?php $content ?&gt;&lt;?php $this-&gt;endcontent ?&gt; 最终将testlayout文件作为一个content变量传递到main中的content View 中可以指定多个 block 块 默认是一个 content,每个block款 要在layout布局文件中 用变量一一对应 如: 1234567891011121314151617181920//View 中指定两个 block&lt;?php $this-&gt;beginBlock(&#x27;content&#x27;);?&gt; &lt;div&gt;test&lt;/div&gt; &lt;?php $this-&gt;endBlock ();?&gt;&lt;?php $this-&gt;beginBlock(&#x27;contenttwo&#x27;);?&gt; &lt;div&gt;test&lt;/div&gt; &lt;?php $this-&gt;endBlock ();?&gt;//那么在 laoyout 中main 文件中 要有两个变量 &lt;?php echo $content ;?&gt;&lt;?php echo $contenttwo ;?&gt; Yii2中 widget 和 assets 的使用： ¶assets 的使用 使用 assets 资源控制器，可以达到按需加载css、js样式的目的，通常会将一个站点的公共部分提取出来，制作layout布局并且制作公共 assets，在layout的布局中将 assets注册进来。 例如： 先定义一个 MainAsset 123456789101112131415161718class MainAsset extends AssetBundle&#123; public $basePath = &#x27;@webroot&#x27;; public $baseUrl = &#x27;@web&#x27;; public $css = [ &#x27;css/base.css&#x27;, ]; public $js = [ ]; public $depends = [ &#x27;yii\\web\\YiiAsset&#x27;, &#x27;yii\\web\\JqueryAsset&#x27;, &#x27;backend\\assets\\FontAwesomeAsset&#x27;, &#x27;yii\\bootstrap\\BootstrapAsset&#x27;, ];&#125; 然后在layout中这样使用 ： 1MainAsset::register($this); //默认会将css添加到header中将js添加到页尾 当有个别页面需要加载不同静态文件时，有两种引用方式： 一：在视图中通过$this-&gt;registerJsFile()引入可以指定依赖关系和加载顺序例如： 123$this-&gt;registerJsFile(&#x27;/js/editormd.js&#x27;,[&#x27;depends&#x27;=&gt;[&#x27;yii\\web\\JqueryAsset&#x27;]]);$this-&gt;registerCssFile(&#x27;/js/editormd.css&#x27;,[&#x27;depends&#x27;=&gt;[&#x27;yii\\web\\JqueryAsset&#x27;]]); 如果在控制器中可以使用当前的视图对象如： 123$view = $this-&gt;getView(); $view-&gt;registerJsFile(&#x27;/js/editormd.js&#x27;,[&#x27;depends&#x27;=&gt;[&#x27;yii\\web\\JqueryAsset&#x27;]]); $view-&gt;registerCssFile($cssfile, [AppAsset::className(), &#x27;depends&#x27; =&gt; &#x27;frontend\\assets\\AppAsset&#x27;]); 二：在单独制作出一个authorassets类 在页面中通过 authorassets ::register($this);注册进来 在控制器中： 12$view = $this-&gt;getView();authorassets::register($view); 在控制器中执行一段js代码： 1$view-&gt;registerJs(&#x27;var &#x27;.$handle.&#x27; = editormd(&#x27;.$options.&#x27;);&#x27;); ¶widget的使用 widget大部分都是在view中使用 分为两种情况： 一：通过数据模型的ActiveField调用 1234567891011&lt;?=$form-&gt;field($model,&#x27;markdown&#x27;)-&gt;widget(&#x27;common\\widgets\\EditorMD&#x27;,[ &#x27;editorConfigs&#x27;=&gt;[ &#x27;height&#x27;=&gt;500, &#x27;markTextarea&#x27;=&gt;&#x27;Article[markdown]&#x27;, &#x27;htmlTextarea&#x27;=&gt;&#x27;Article[content]&#x27;, &#x27;saveHTMLToTextarea&#x27;=&gt;true, ], &#x27;editorOptions&#x27;=&gt;[ &#x27;style&#x27;=&gt;&#x27;z-index:1000;&#x27;, ]])?&gt; 在ActiveField中会自动触发我们自定义的widget如： 12345678910public function widget($class, $config = [])&#123; /* @var $class \\yii\\base\\Widget */ $config[&#x27;model&#x27;] = $this-&gt;model; $config[&#x27;attribute&#x27;] = $this-&gt;attribute; $config[&#x27;view&#x27;] = $this-&gt;form-&gt;getView(); $this-&gt;parts[&#x27;&#123;input&#125;&#x27;] = $class::widget($config); return $this;&#125; 二：直接使用 1&lt;?= \\backend\\widgets\\UploadWidget::widget([&#x27;id&#x27; =&gt; &#x27;icon_5&#x27;, &#x27;upload_success&#x27; =&gt; &#x27;upload_success&#x27;]) ?&gt; 设计widget的步骤： 定义属性：调用widget的时候传的属性值要在widget中先定义 widget调用初始化时init()的逻辑 最后run()进行输出。","raw":null,"content":null,"categories":[{"name":"Yii","slug":"Yii","permalink":"http://blog.nicexiangcun.com/categories/Yii/"}],"tags":[{"name":"Yii","slug":"Yii","permalink":"http://blog.nicexiangcun.com/tags/Yii/"}]}]}