<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>人工智能的发展历史</title>
    <url>/blog/2023/03/24/AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="https://cdn.chuangketime.com/AI/chatgpt-demo.gif" alt="gpt-demo"></p>
<p>上面是最近一直比较🔥聊天机器人chatgpt的一个小测试，在人工智能领域这个概念早在1950年就被英国著名计算机科学家图灵提出了，1950年图灵提出了一个概念说机器能不能像人一样思考，并且他还针对自己提出的概念提出了一个测试方法也就是后来被称为的图灵测试，就是说在一个相对隔离的环境下一个人向对面的一台机器提问如果得到的回答他不能区分出到底是人还是机器，或者有30%的概率他相信是一个人的话，就说明这台机器通过了图灵测试，是不是和最近人工智能领域的chartgpt很像呢，但是呢图灵当时还有一个大胆的预测说是在大概2000年左右的时候,人类的人工智能就能达到这种水平，但是呢人工智能的发展也经历了几次低谷，下面我们来看一下人工智能的发展历史。</p>
<span id="more"></span>
<p><img src="https://cdn.chuangketime.com/AI/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E8%BD%A8%E8%BF%B9%E5%9B%BE.png" alt="AI-history"></p>
<h2 id="孕育期（-1956-年以前）"><a href="#孕育期（-1956-年以前）" class="headerlink" title="孕育期（ 1956 年以前）"></a>孕育期（ 1956 年以前）</h2><h3 id="数理逻辑-符号主义学派"><a href="#数理逻辑-符号主义学派" class="headerlink" title="数理逻辑-符号主义学派"></a>数理逻辑-符号主义学派</h3><ul>
<li><p>在数理逻辑初创期，亚里斯多德（公元前 384 一 322 ，古希腊伟大的哲学家和科学家），创立<a href="https://baike.baidu.com/item/%E6%BC%94%E7%BB%8E%E6%8E%A8%E7%90%86">演绎法</a>，提出了演绎推理的一般原则-三段论</p>
</li>
<li><p>在逻辑代数时期，莱布尼茨（1646 一 1716 ，德国数学家和哲学家）把形式逻辑符号化，奠定了数理逻辑的基础。</p>
</li>
</ul>
<h3 id="人工神经网络-连接主义学派"><a href="#人工神经网络-连接主义学派" class="headerlink" title="人工神经网络-连接主义学派"></a>人工神经网络-连接主义学派</h3><ul>
<li>1890 年美国生物学家詹姆士首次阐明人脑的结构及功能，及记忆、学习、联想相关功能的规律。</li>
<li>1943 年美国神经生理学家麦克洛奇和皮兹建成第一个神经网络模型 <a href="https://baike.baidu.com/item/%E9%BA%A6%E5%8D%A1%E6%B4%9B%E5%85%8B%E4%B8%80%E5%8C%B9%E5%85%B9%E6%A8%A1%E5%9E%8B">MP 模型</a>。</li>
<li>1949 年加拿大心理学家赫布提出了改变神经网络连接强度的 <a href="https://baike.baidu.com/item/Hebb%E5%AE%9A%E5%BE%8B">Hebb 规则</a>。</li>
</ul>
<h3 id="行为主义学派"><a href="#行为主义学派" class="headerlink" title="行为主义学派"></a>行为主义学派</h3><ul>
<li>维纳( 1874 一 1956 )：美国著名数学家、控制论创始人。 1948 年创立了控制论。控制论对人工智能的影响，形成了行为主义学派。</li>
</ul>
<h3 id="人工智能的载体-计算机"><a href="#人工智能的载体-计算机" class="headerlink" title="人工智能的载体-计算机"></a>人工智能的载体-计算机</h3><p>美国数学家莫克利和艾克特于 1946 年 2 月 14 日研制成功了第一台通用计算机ENIAC。</p>
<p>它每秒能完成 5000 次加法，400 次乘法等运算。</p>
<p>ENIAC 为人工智能研究奠定物质基础。</p>
<h3 id="图灵（1912-一-1954）：英国数学家"><a href="#图灵（1912-一-1954）：英国数学家" class="headerlink" title="图灵（1912 一 1954）：英国数学家"></a>图灵（1912 一 1954）：英国数学家</h3><ul>
<li>1936 年创立了自动机理论亦称图灵机。</li>
<li>1950 年在其著作《计算机与智能》中首次提出“机器也能思维”</li>
<li>图灵设计了一个图灵试验，试图通过让机器模仿人回答某些问题，判断它是否具备智能。</li>
<li>图灵的机器智能思想是人工智能的直接起源之一，被誉为“人工智能之父”。</li>
<li>2019 年 7 月，英国政府宣布图灵登上 50 英镑钞票。荣耀比肩牛顿、达尔文</li>
</ul>
<h3 id="人工智能诞生（1956-年）"><a href="#人工智能诞生（1956-年）" class="headerlink" title="人工智能诞生（1956 年）"></a>人工智能诞生（1956 年）</h3><p>AI 诞生于一次历史性的聚会。</p>
<ul>
<li>时间：1956 年夏季</li>
<li>地点：达特莫斯( Dartmouth )大学</li>
<li>目的：为使计算机变得更“聪明”，或者说使计算机具有智能</li>
<li>发起人：<ul>
<li>麦卡锡（J.McCarthy）， Dartmouth 的年轻数学家、计算机专家，后为 MIT 教授</li>
<li>明斯基 （M.L.Minsky），哈佛大学数学家、神经学家，后为 MIT 教授</li>
<li>洛切斯特 （N.Lochester)， IBM 公司信息中心负责人</li>
<li>香农（C.E.Shannon），贝尔实验室信息部数学研究员</li>
</ul>
</li>
<li>参加人：<ul>
<li>莫尔（T.more）、塞缪尔（A.L.Samuel）， IBM 公司</li>
<li>塞尔夫里奇（O.Selfridge）、索罗蒙夫（R.Solomonff）， MIT</li>
<li>纽厄尔（A.Newell），兰德 （RAND）公司</li>
<li>西蒙（H.A.Simon），卡内基（Carnagie）工科大学</li>
</ul>
</li>
<li>会议结果：由麦卡锡提议正式采用了Artificial Intelligence这一术语。</li>
</ul>
<h2 id="形成期（1956-1974）"><a href="#形成期（1956-1974）" class="headerlink" title="形成期（1956 - 1974）"></a>形成期（1956 - 1974）</h2><h3 id="形成期（1956-1974）：迅速发展"><a href="#形成期（1956-1974）：迅速发展" class="headerlink" title="形成期（1956 - 1974）：迅速发展"></a>形成期（1956 - 1974）：迅速发展</h3><ul>
<li>1956年，塞缪尔在 IBM 计算机上研制成功了的西洋跳棋程序，它顺利战胜了当时的西洋棋大师罗伯特尼赖。</li>
<li>1957年，纽厄尔、肖和西蒙等研制了一个称为逻辑理论机( LT )的数学定理证明程序。</li>
<li>1960年，麦卡锡开发了 LISP 语言，成为以后几十年来人工智能领域最主要的编程语言.</li>
<li>1965年，鲁宾逊提出了归结（消解)原理。</li>
<li>1968年，美国斯坦福研究所（SRI）研发的首台智能机器人 Shakey ，它拥有类似人的感觉，如触觉、听觉等。</li>
</ul>
<h2 id="低谷期（1974-1980）"><a href="#低谷期（1974-1980）" class="headerlink" title="低谷期（1974-1980）"></a>低谷期（1974-1980）</h2><ul>
<li>过高预言的失败，给 AI 的声誉造成重大伤害。</li>
<li>“20 年内，机器将能做人所能做的一切。”一西蒙，1965</li>
<li>“在 3 - 8 年时间里，我们将研制出具有普通人智力的计算机。这样的机器能读懂莎士比亚的著作，会给汽车上润滑油，会玩弄政治权术，能讲笑话，会争吵。 …它的智力将无以伦比。 ” —— 明斯基，1977</li>
<li>塞缪尔的下棋程序在与世界冠军对弈时，以 1 比 4 告负。</li>
<li>归结法的能力有限。当用归结原理证明“两连续函数之和仍然是连续函数”时，推了 10 万步也没证明出结果来。</li>
<li>把“心有余而力不足”（The spirit is willing but the flesh is weak）的英语句子翻译成俄语，再翻译回来时竟变成了“酒是好的，肉变质了”</li>
<li>英国剑桥大学数学家詹姆士按照英国政府的旨意，发表一份关于人工智能的综合报告，声称人工智能即使不是骗局也是庸人自扰。</li>
</ul>
<h2 id="黄金时期（1980-1987-年）"><a href="#黄金时期（1980-1987-年）" class="headerlink" title="黄金时期（1980 - 1987 年）"></a>黄金时期（1980 - 1987 年）</h2><ul>
<li>实现了人工智能从理论研究走向专门知识应用，是 AI 发展史上的一次重要突破与转折。</li>
<li>1976年，费根鲍姆研制 MYCN 专家系统，用于协助内科医生诊断细菌感染疾病，并提供最佳处方。</li>
<li>1976年，斯坦福大学的杜达等人研制地质勘探专家系统 PROSPECTOR 。</li>
</ul>
<h2 id="平稳发展期（1993-2011）"><a href="#平稳发展期（1993-2011）" class="headerlink" title="平稳发展期（1993 - 2011）"></a>平稳发展期（1993 - 2011）</h2><ul>
<li>机器学习、人工神经网络、智能机器人和行为主义研究趋向深入。</li>
<li>智能计算（CI） 弥补了人工智能在数学理论和计算上的不足，更新和丰富了人工智能理论框架，使人工智能进入一个新的发展时期。</li>
<li>1997年，“深蓝”战胜国际象棋世界冠军 2000 年，本田公司发布了机器人产品 ASIMO ，经过十多年的升级改进，目前已经是全世界最先进的机器人之一。</li>
<li>2011年， IBM 开发的人工智能程序“沃森”( Watson )参加了一档智力问答节目并战胜了两位人类冠军。</li>
</ul>
<h2 id="蓬勃发展期：-2012-至今"><a href="#蓬勃发展期：-2012-至今" class="headerlink" title="蓬勃发展期： 2012 - 至今"></a>蓬勃发展期： 2012 - 至今</h2><ul>
<li>数据的爆发式增长为人工智能提供了充分的养料，泛在感知数据和图形处理器等计算平台及新型的以深度学习为代表的新方法等因素合力造势，人工智能迎来它的蓬勃发展期。</li>
<li>人类已经正式跨入了人工智能的时代。</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
        <category>发展史</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能基础理论-数学公式</title>
    <url>/blog/2022/03/23/AI%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-%E6%95%B0%E6%8D%AE%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><script type="math/tex; mode=display">f(x)=\frac{1}{1+e^{x}}</script><p>$x^p_ {ij}$</p>
<p>$x_ {ij}$</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>基础理论</category>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能基础理论-线性代数-矩阵</title>
    <url>/blog/2023/04/01/AI%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="理解-标量、向量、矩阵、张量"><a href="#理解-标量、向量、矩阵、张量" class="headerlink" title="理解 标量、向量、矩阵、张量"></a>理解 标量、向量、矩阵、张量</h2><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>万事万物都可以抽象为具有某些特征的组合，这些组合可以理解为是一个集合set,集合是线性代数最基本的一个概念，集合是由具有某些特征的对象汇聚的集体，</p>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>上面说集合是由具有某些特征的标量组成的，e.g  a<sub>1</sub>  a<sub>2</sub> a<sub>3</sub> a<sub>n</sub>那么 （a<sub>1</sub>….a<sub>n</sub>） 就构成了一个维度上的向量。向量不但有大小还有方向，方向代表了它的一个维度，标量只有大小没有方向。</p>
<p>向量带来了维度的增加，是数据分析转化的最基本元素,通常数据的每一个属性代表着一个维度。每个属性值在多维的空间里都有一个确定的点。</p>
<span id="more"></span>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>向量描述了事物属性的维度和大小，那么当一个集合里有多组向量时，就代表着有多个维度和大小的特征向量描述着这个集合，</p>
<p>e.g: t 时刻下每种油品账户的余额 矩阵</p>
<script type="math/tex; mode=display">
 \left\{
 \begin{matrix}
   a_{t1柴油} & a_{t1汽油} & a_{t1然气 } \\
   a_{t2柴油} & a_{t2汽油} & a_{t2然气 } \\
   a_{t3柴油} & a_{t3汽油} & a_{t3然气 }
  \end{matrix}
  \right\}</script><p>数据矩阵表现形式</p>
<script type="math/tex; mode=display">
 \left\{
 \begin{matrix}
   a_{11} & a_{12} & a_{13} \\
   a_{21} & a_{22} & a_{23} \\
   a_{31} & a_{32} & a_{33}
  \end{matrix}
  \right\}</script><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3>]]></content>
      <categories>
        <category>AI</category>
        <category>基础理论</category>
        <category>线性代数</category>
        <category>线性空间</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>向量点乘与叉乘的几何意义</title>
    <url>/blog/2023/03/01/AI%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E4%B9%98%E7%A7%AF%E7%9A%84%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<h3 id="向量的点乘-（叉乘）"><a href="#向量的点乘-（叉乘）" class="headerlink" title="向量的点乘 （叉乘）"></a>向量的点乘 （叉乘）</h3>]]></content>
      <categories>
        <category>AI</category>
        <category>基础理论</category>
        <category>线性代数</category>
        <category>线性空间</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos环境下安装Rabbitmq步骤</title>
    <url>/blog/2023/03/23/Centos%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85Rabbitmq/</url>
    <content><![CDATA[<h1 id="软件包准备"><a href="#软件包准备" class="headerlink" title="软件包准备"></a>软件包准备</h1><p>1.RabbitMQ版本 和 Erlang 版本兼容性关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.rabbitmq.com/which-erlang.html</span><br></pre></td></tr></table></figure>
<p>2.官方下载地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【erlang下载地址】：https://github.com/rabbitmq/erlang-rpm/releases</span><br><span class="line"> </span><br><span class="line">【socat下载地址】：http://www.rpmfind.net/linux/rpm2html/search.php?query=socat(x86-64)</span><br><span class="line"> </span><br><span class="line">【rabbitmq下载地址】：https://github.com/rabbitmq/rabbitmq-server/releases</span><br></pre></td></tr></table></figure>
<p>3.安装包中说明，请下载对应的安装包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">el6：CentOS 6.x 的下载</span><br><span class="line">el7：CentOS 7.x 的下载</span><br><span class="line">el8：CentOS 8.x 的下载</span><br></pre></td></tr></table></figure>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><span id="more"></span>
<p>1.安装依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure>
<p>2.准备软件包</p>
<ul>
<li>erlang-23.3.4.8-1.el7.x86_64.rpm</li>
<li>rabbitmq-server-3.9.11-1.el7.noarch.rpm</li>
<li>socat-1.7.3.2-2.el7.x86_64.rpm</li>
</ul>
<p>3.创建软件包下载目录</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rabbitmq &amp;&amp; <span class="built_in">cd</span> rabbitmq</span><br></pre></td></tr></table></figure>
<p>4.安装 Erlang</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh erlang-23.3.4.8-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>5.检查Erlang安装状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">erl -v</span><br></pre></td></tr></table></figure>
<p>6.安装socat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh socat-1.7.3.2-2.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>7.安装rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh rabbitmq-server-3.9.11-1.el7.noarch.rpm</span><br><span class="line"><span class="comment"># 检查是否安装成功命令</span></span><br><span class="line">rpm -qa|grep rabbitmq</span><br></pre></td></tr></table></figure>
<p>8.开启管理界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>9.添加配置文件，解决只能localhost访问的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进入【/etc/rabbitmq】文件夹下</span><br><span class="line"><span class="built_in">cd</span> /etc/rabbitmq</span><br><span class="line">编辑【rabbitmq.config】文件</span><br><span class="line">vim rabbitmq.config</span><br><span class="line">[&#123;rabbit,[&#123;loopback_users,[]&#125;]&#125;].</span><br></pre></td></tr></table></figure>
<p>10.启动rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	启动rabbitmq命令：</span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line">	看启动状态命令：</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>11.停止rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">停止rabbitmq命令：</span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"> </span><br><span class="line">查看启动状态命令：</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>12.重启rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">重启rabbitmq命令：</span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line"> </span><br><span class="line">查看启动状态命令：</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>13.开放端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开放5672端口命令</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 5672 -j ACCEPT</span><br><span class="line"> </span><br><span class="line">开放15672端口命令</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>14.登录管理界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">URL地址：http://192.168.109.101:15672/</span><br><span class="line">默认账号：guest</span><br><span class="line">默认密码：guest</span><br></pre></td></tr></table></figure>
<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>一、卸载rabbitmq相关文件</p>
<ol>
<li>systemctl stop rabbitmq-server</li>
<li>yum list | grep rabbitmq</li>
<li>yum -y remove rabbitmq-server.noarch</li>
</ol>
<p>二、 卸载erlang</p>
<ol>
<li>yum list | grep erlang</li>
<li>yum -y remove erlang-*</li>
</ol>
<p>三、 删除有关的所有文件</p>
<p>rm -rf /usr/lib64/erlang<br>rm -rf /var/lib/rabbitmq<br>rm -rf /usr/local/erlang<br>rm -rf /usr/local/rabbitmq</p>
<h1 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h1><p><a href="https://blog.csdn.net/shishishilove/article/details/122086399">https://blog.csdn.net/shishishilove/article/details/122086399</a></p>
]]></content>
      <categories>
        <category>基础服务</category>
        <category>消息总线</category>
      </categories>
      <tags>
        <tag>Rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenResty的一个非常有用的多级缓存库</title>
    <url>/blog/2023/03/24/Lua-resty-mlcache%E5%BA%93/</url>
    <content><![CDATA[<p>OpenResty 中有两个缓存的组件：shared dict 缓存和 lru 缓存。前者只能缓存字符串对象，缓存的数据有且只有一份，每一个 worker 都可以进行访问，所以常用于 worker 之间的数据通信,同时还支持对过期的数据进行访问获取。后者则可以缓存所有的 Lua 对象，但只能在单个 worker 进程内访问，有多少个 worker，就会有多少份缓存数据。</p>
<h4 id="lua-resty-mlcache"><a href="#lua-resty-mlcache" class="headerlink" title="lua-resty-mlcache"></a>lua-resty-mlcache</h4><p>这个库可以作为 key/value存储来处理，也可以缓存Lua类型和表，构建在lua_shared_dict，lua-resty-lrucache上 ，这种组合可以实现高性能和灵活的缓存。</p>
<span id="more"></span>
<p>功能：</p>
<ul>
<li>使用TTL缓存和负缓存，</li>
<li>通过lua-resty-lock构建互斥体，以防止在缓存失败时将狗堆影响到数据库/后端，</li>
<li>内置worker通信，传播缓存失效，并允许worker更新他们的L1 (lua-resty-lrucache )缓存的更改(set()，delete() )，</li>
<li>可以创建多个独立实例来保存各种类型的数据，同时依赖同一lua_shared_dict L2缓存，</li>
</ul>
<p>此库中内置的各种缓存级别的说明，引用官方图片说明。</p>
<p><img src="http://cdn.chuangketime.com/lua-resty-lrucache.jpg" alt="lrucache1"></p>
<p><img src="https://cdn.chuangketime.com/lua-resty-mlcache.png" alt="lrucache2"></p>
<p> 缓存级别层次结构为：</p>
<ul>
<li><p>L1 ：使用Least-Recently-Used land缓存lua-resty-lrucache ，在填充时提供最快的查找，并避免耗尽worker的Lua虚拟机内存，</p>
</li>
<li><p>L2 ：所有员工共享的lua_shared_dict内存区域，只有L1未命中时才能访问此级别，并防止工作人员请求L3缓存，</p>
</li>
<li><p>L3 ：自定义函数，只由单个worker运行，以避免数据库/后端(通过lua-resty-lock )上的狗堆效应，通过L3获取的值将被设置为L2缓存，供其他员工访问，</p>
</li>
</ul>
]]></content>
      <categories>
        <category>基础服务</category>
        <category>网关</category>
      </categories>
      <tags>
        <tag>OpenResty</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Django 框架安装使用</title>
    <url>/blog/2023/03/29/Python%20Django%20%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="准备python环境"><a href="#准备python环境" class="headerlink" title="准备python环境"></a>准备python环境</h3><ol>
<li>用brew安装</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">brew install python3</span><br></pre></td></tr></table></figure>
<ol>
<li><p>查看bin目录位置</p>
<ul>
<li>brew 安装后的软件通常会在 /usr/local/bin有指向/usr/local/Cellar相对应软件的软连，而/usr/local/bin 通常情况下已经在你的环境变量中，如果你的系统没有其他版本的python的话，直接使用即可。</li>
<li>由于mac系统下可能会存在其他版本的python.如果启用自定义安装的版本需要覆盖掉默认的版本，可以配置环境变量 ~/.bash_profile 或 ~/.zshrc 配置你的别名指向位置</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias python=&quot;/usr/local/bin/python3.9&quot;</span><br><span class="line">alias pip=/usr/local/bin/pip3.9</span><br></pre></td></tr></table></figure>
<h3 id="安装-django"><a href="#安装-django" class="headerlink" title="安装 django"></a>安装 django</h3><p>pip install —upgrade pip</p>
<p>python -m pip install Django</p>
<p>pip install mysqlclient  #mac 使用mysqlclient 需要找到libmysqlclient.21.dylib路径并导入环境变量 e.g export LD_LIBRARY_PATH=/usr/local/mysql-8.0.22-macos10.15-x86_64/lib/</p>
<p>pip install pytz</p>
<p>pip install djangorestframework  # see: <a href="https://www.django-rest-framework.org/">https://www.django-rest-framework.org/</a></p>
<p>pycharm install djangorestframework </p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><pre><code>todo 
</code></pre>]]></content>
      <categories>
        <category>计算机语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表数据结构</title>
    <url>/blog/2023/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
    hashtable是由数组和列表两种数据结构组合而成的，这里面有两个重要的知识点需要掌握，一个是如何对哈希表进行动态扩容，第二个如何巧妙的设计一个散列性和性能都非常好的散列函数。
</blockquote>

<span id="more"></span>
<p><img src="https://cdn.chuangketime.com/hashtable.png" alt="hashtable"></p>
<h3 id="数组的动态扩容策略"><a href="#数组的动态扩容策略" class="headerlink" title="数组的动态扩容策略"></a>数组的动态扩容策略</h3><p>已java的 <code>hashmap</code>为例，它的初始长度是16，默认阀值为0.75，当存储长度达到了长度的3/4时，就会触发扩容动作，扩容的长度为2的整数次幂，这是因为2的整数次幂的数据减1转为二进制，低位都是1，在与hashcode随机出来的数转为二进制做与运算，其结果范围一定是0-hashcode之间的范围，不会越界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bucketIndex = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>好的散列函数不但要保证计算速度快，还要保证散列性好，避免过多的碰撞，扰动函数的逻辑是将二进制数据右位移16位，正好是32bit的一半，然后自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p><img src="https://cdn.chuangketime.com/hashcode.jpg" alt="hashtable"></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中内存字节对齐</title>
    <url>/blog/2023/03/12/%E5%86%85%E5%AD%98%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p>:cherries: Linux下默认字节对齐是以int类型变量所占字节数对齐，也就是说会申请被4整除的内存地址写入int类型，所以这就是我们每次看int类型的地址不会看到有奇数的。</p>
<h4 id="什么叫对齐"><a href="#什么叫对齐" class="headerlink" title="什么叫对齐"></a>什么叫对齐</h4><p>   计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。 </p>
<h4 id="为什么要进行对齐"><a href="#为什么要进行对齐" class="headerlink" title="为什么要进行对齐"></a>为什么要进行对齐</h4><span id="more"></span>
<p>   各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据（linux中：在内存中是低位在先，高位在后）。显然在读取效率上下降很多。</p>
<p>例1程序分配的内存地址如下图：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">9.99</span>;</span><br><span class="line">    <span class="type">char</span>   b = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="type">int</span>    c =  <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(a):%lu\n&quot;</span>,&amp;a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(b):%lu\n&quot;</span>,&amp;b,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(c):%lu\n&quot;</span>,&amp;c,<span class="keyword">sizeof</span>(c));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.chuangketime.com/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png" alt="计算机内存字节对齐"></p>
<p>例2程序分配的内存地址如下图：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">char</span>   a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">   <span class="type">double</span> b = <span class="number">9.99</span>;</span><br><span class="line">   <span class="type">char</span>   c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">   <span class="type">int</span>    d =  <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(a):%lu\n&quot;</span>,&amp;a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(b):%lu\n&quot;</span>,&amp;b,<span class="keyword">sizeof</span>(b));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(c):%lu\n&quot;</span>,&amp;c,<span class="keyword">sizeof</span>(c));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(d):%lu\n&quot;</span>,&amp;d,<span class="keyword">sizeof</span>(d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.chuangketime.com/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%902.png" alt="计算机内存字节对齐"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>内存</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和链表对比</title>
    <url>/blog/2023/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>数组的特点是在内存中地址是连续的，所以在随机访问一个数组中的地址的时间复杂度是O(1),寻址公式大概是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">a[i]_address = begin_address + i * data_type_size</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">address = begin_address + ( i * n + j) * data_type_size</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组由于对内存的要求比较苛刻，带来的一个问题就是低效的“插入”和“删除”，在做数据的插入和删除的时候要频繁的进行数据的迁移。对于数组的动态扩容策略的实现可以参考redis的字符串底层实现原理或者java中的arrayList&lt;&gt;.</p>
<span id="more"></span>
<p>使用场景注意： 操作的数据不宜过大。</p>
<p>链表的分类：</p>
<p>单链表：   后继指针指next向下一个节点的heac（节点包含头部，数据data和指针next）<br>双向链表： 后继指针next指向下一个节点的prev (节点包括前驱指针prev,数据data,后继指针next)<br>循环链表： 尾结点指针指向头节点</p>
<p>链表就是用指针将节点连接起来，它对内存的要求没有数组那么苛刻，所以链表在“插入”和“删除”的动作上的时间复杂度是O(1),但是由于链表内存不是连续的，所以不能随机访问某个元素，在查找的时候时间复杂度是O(n)。</p>
<p>单链表的使用经典案例如：LRU缓存淘汰策略 </p>
<p>双向链表：java中的<code>LinkedHashMap</code>实现，双向链表比单链表会占用更多的内存，但是在查找元素的速度上会比单链表性能更高，因为双向链表的每个节点上既有前驱指针，又有后继指针，当我们知道具体某一个node的时候那么它的前驱和后继指针我们就知道了，所以它在查找过程中可以判断是忘前走还是往后走，体现了用空间换时间的设计思想。</p>
<p>链表的另一种使用场景经常会配合散列表使用，配合<code>hashtable</code>使用的目的主要是为了解决链表在查询过程中时间复杂度O(N)的问题。做法是将单链表或者双链表中的节点通过hash函数散列到数组的槽(桶)上，用一个新的指针通过拉链的方式将冲突的节点连接上。这样在查找某一个node的时候，时间复杂度是接近O(1)的。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>Hashtable</tag>
        <tag>Linklist</tag>
      </tags>
  </entry>
</search>
