<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>人工智能基础理论-数据公式</title>
    <url>/2023/03/23/AI%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA-%E6%95%B0%E6%8D%AE%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>AI</category>
        <category>基础理论</category>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos环境下安装Rabbitmq步骤</title>
    <url>/2023/03/23/Centos%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85Rabbitmq/</url>
    <content><![CDATA[<h1>软件包准备</h1>
<p>1.RabbitMQ版本 和 Erlang 版本兼容性关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.rabbitmq.com/which-erlang.html</span><br></pre></td></tr></table></figure>
<p>2.官方下载地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【erlang下载地址】：https://github.com/rabbitmq/erlang-rpm/releases</span><br><span class="line"> </span><br><span class="line">【socat下载地址】：http://www.rpmfind.net/linux/rpm2html/search.php?query=socat(x86-64)</span><br><span class="line"> </span><br><span class="line">【rabbitmq下载地址】：https://github.com/rabbitmq/rabbitmq-server/releases</span><br></pre></td></tr></table></figure>
<p>3.安装包中说明，请下载对应的安装包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">el6：CentOS 6.x 的下载</span><br><span class="line">el7：CentOS 7.x 的下载</span><br><span class="line">el8：CentOS 8.x 的下载</span><br></pre></td></tr></table></figure>
<h1>安装步骤</h1>
<span id="more"></span>
<p>1.安装依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure>
<p>2.准备软件包</p>
<ul>
<li>erlang-23.3.4.8-1.el7.x86_64.rpm</li>
<li>rabbitmq-server-3.9.11-1.el7.noarch.rpm</li>
<li>socat-1.7.3.2-2.el7.x86_64.rpm</li>
</ul>
<p>3.创建软件包下载目录</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rabbitmq &amp;&amp; <span class="built_in">cd</span> rabbitmq</span><br></pre></td></tr></table></figure>
<p>4.安装 Erlang</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh erlang-23.3.4.8-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>5.检查Erlang安装状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">erl -v</span><br></pre></td></tr></table></figure>
<p>6.安装socat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh socat-1.7.3.2-2.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>7.安装rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh rabbitmq-server-3.9.11-1.el7.noarch.rpm</span><br><span class="line"><span class="comment"># 检查是否安装成功命令</span></span><br><span class="line">rpm -qa|grep rabbitmq</span><br></pre></td></tr></table></figure>
<p>8.开启管理界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>9.添加配置文件，解决只能localhost访问的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">进入【/etc/rabbitmq】文件夹下</span><br><span class="line"><span class="built_in">cd</span> /etc/rabbitmq</span><br><span class="line">编辑【rabbitmq.config】文件</span><br><span class="line">vim rabbitmq.config</span><br><span class="line">[&#123;rabbit,[&#123;loopback_users,[]&#125;]&#125;].</span><br></pre></td></tr></table></figure>
<p>10.启动rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	启动rabbitmq命令：</span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line">	看启动状态命令：</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>11.停止rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">停止rabbitmq命令：</span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"> </span><br><span class="line">查看启动状态命令：</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>12.重启rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">重启rabbitmq命令：</span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line"> </span><br><span class="line">查看启动状态命令：</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>13.开放端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开放5672端口命令</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 5672 -j ACCEPT</span><br><span class="line"> </span><br><span class="line">开放15672端口命令</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>14.登录管理界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">URL地址：http://192.168.109.101:15672/</span><br><span class="line">默认账号：guest</span><br><span class="line">默认密码：guest</span><br></pre></td></tr></table></figure>
<h1>卸载</h1>
<p>一、卸载rabbitmq相关文件</p>
<ol>
<li>systemctl stop rabbitmq-server</li>
<li>yum list | grep rabbitmq</li>
<li>yum -y remove rabbitmq-server.noarch</li>
</ol>
<p>二、 卸载erlang</p>
<ol>
<li>yum list | grep erlang</li>
<li>yum -y remove erlang-*</li>
</ol>
<p>三、 删除有关的所有文件</p>
<p>rm -rf /usr/lib64/erlang<br>
rm -rf /var/lib/rabbitmq<br>
rm -rf /usr/local/erlang<br>
rm -rf /usr/local/rabbitmq</p>
<h1>参考地址：</h1>
<p><a href="https://blog.csdn.net/shishishilove/article/details/122086399">https://blog.csdn.net/shishishilove/article/details/122086399</a></p>
]]></content>
      <categories>
        <category>基础服务</category>
        <category>消息总线</category>
      </categories>
      <tags>
        <tag>Rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中内存字节对齐</title>
    <url>/2023/03/12/%E5%86%85%E5%AD%98%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p>🍒 Linux下默认字节对齐是以int类型变量所占字节数对齐，也就是说会申请被4整除的内存地址写入int类型，所以这就是我们每次看int类型的地址不会看到有奇数的。</p>
<h4 id="什么叫对齐"><a class="header-anchor" href="#什么叫对齐">¶</a>什么叫对齐</h4>
<p>计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<h4 id="为什么要进行对齐"><a class="header-anchor" href="#为什么要进行对齐">¶</a>为什么要进行对齐</h4>
<span id="more"></span>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据（linux中：在内存中是低位在先，高位在后）。显然在读取效率上下降很多。</p>
<p>例1程序分配的内存地址如下图：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">9.99</span>;</span><br><span class="line">    <span class="type">char</span>   b = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="type">int</span>    c =  <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(a):%lu\n&quot;</span>,&amp;a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(b):%lu\n&quot;</span>,&amp;b,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(c):%lu\n&quot;</span>,&amp;c,<span class="keyword">sizeof</span>(c));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.chuangketime.com/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png" alt="计算机内存字节对齐"></p>
<p>例2程序分配的内存地址如下图：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">char</span>   a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">   <span class="type">double</span> b = <span class="number">9.99</span>;</span><br><span class="line">   <span class="type">char</span>   c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">   <span class="type">int</span>    d =  <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(a):%lu\n&quot;</span>,&amp;a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(b):%lu\n&quot;</span>,&amp;b,<span class="keyword">sizeof</span>(b));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(c):%lu\n&quot;</span>,&amp;c,<span class="keyword">sizeof</span>(c));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p,sizeof(d):%lu\n&quot;</span>,&amp;d,<span class="keyword">sizeof</span>(d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.chuangketime.com/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%902.png" alt="计算机内存字节对齐"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>内存</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能基础理论-线性代数</title>
    <url>/2023/03/23/AI%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>AI</category>
        <category>基础理论</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表数据结构</title>
    <url>/2023/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
	hashtable是由数组和列表两种数据结构组合而成的，这里面有两个重要的知识点需要掌握，一个是如何对哈希表进行动态扩容，第二个如何巧妙的设计一个散列性和性能都非常好的散列函数。
</blockquote>
<span id="more"></span>
<p><img src="https://cdn.chuangketime.com/hashtable.png" alt="hashtable"></p>
<h3 id="数组的动态扩容策略"><a class="header-anchor" href="#数组的动态扩容策略">¶</a>数组的动态扩容策略</h3>
<p>已java的 <code>hashmap</code>为例，它的初始长度是16，默认阀值为0.75，当存储长度达到了长度的3/4时，就会触发扩容动作，扩容的长度为2的整数次幂，这是因为2的整数次幂的数据减1转为二进制，低位都是1，在与hashcode随机出来的数转为二进制做与运算，其结果范围一定是0-hashcode之间的范围，不会越界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bucketIndex = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="散列函数"><a class="header-anchor" href="#散列函数">¶</a>散列函数</h3>
<p>好的散列函数不但要保证计算速度快，还要保证散列性好，避免过多的碰撞，扰动函数的逻辑是将二进制数据右位移16位，正好是32bit的一半，然后自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p><img src="https://cdn.chuangketime.com/hashcode.jpg" alt="hashtable"></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和链表对比</title>
    <url>/2023/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>数组的特点是在内存中地址是连续的，所以在随机访问一个数组中的地址的时间复杂度是O(1),寻址公式大概是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">a[i]_address = begin_address + i * data_type_size</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">address = begin_address + ( i * n + j) * data_type_size</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组由于对内存的要求比较苛刻，带来的一个问题就是低效的“插入”和“删除”，在做数据的插入和删除的时候要频繁的进行数据的迁移。对于数组的动态扩容策略的实现可以参考redis的字符串底层实现原理或者java中的arrayList&lt;&gt;.</p>
<span id="more"></span>
<p>使用场景注意： 操作的数据不宜过大。</p>
<p>链表的分类：</p>
<p>单链表：   后继指针指next向下一个节点的heac（节点包含头部，数据data和指针next）<br>
双向链表： 后继指针next指向下一个节点的prev (节点包括前驱指针prev,数据data,后继指针next)<br>
循环链表： 尾结点指针指向头节点</p>
<p>链表就是用指针将节点连接起来，它对内存的要求没有数组那么苛刻，所以链表在“插入”和“删除”的动作上的时间复杂度是O(1),但是由于链表内存不是连续的，所以不能随机访问某个元素，在查找的时候时间复杂度是O(n)。</p>
<p>单链表的使用经典案例如：LRU缓存淘汰策略</p>
<p>双向链表：java中的<code>LinkedHashMap</code>实现，双向链表比单链表会占用更多的内存，但是在查找元素的速度上会比单链表性能更高，因为双向链表的每个节点上既有前驱指针，又有后继指针，当我们知道具体某一个node的时候那么它的前驱和后继指针我们就知道了，所以它在查找过程中可以判断是忘前走还是往后走，体现了用空间换时间的设计思想。</p>
<p>链表的另一种使用场景经常会配合散列表使用，配合<code>hashtable</code>使用的目的主要是为了解决链表在查询过程中时间复杂度O(N)的问题。做法是将单链表或者双链表中的节点通过hash函数散列到数组的槽(桶)上，用一个新的指针通过拉链的方式将冲突的节点连接上。这样在查找某一个node的时候，时间复杂度是接近O(1)的。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>Hashtable</tag>
        <tag>Linklist</tag>
      </tags>
  </entry>
</search>
